// Copyright (c) 2017 nyorain
// Distributed under the Boost Software License, Version 1.0.
// See accompanying file LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt

// Automaitcally generated vulkan header, see nyorain/vkpp
// Do not edit manually, rather edit the codegen files.

#pragma once
#include <vkpp/fwd.hpp>
#include <vkpp/enums.hpp>
#include <vkpp/structs.hpp>
#include <vkpp/call.hpp>
#include <vkpp/span.hpp>
#include <vkpp/flags.hpp>

#include <vector>
#include <vulkan/vulkan.h>

// Generated for vulkan version: 1.1.107
#if !defined(VK_VERSION_1_1) || 107 > VK_HEADER_VERSION
	#error "vulkan.h version too old, does not match generated version"
#endif

// normal dispatch versions
#define VEC_FUNC(D, T, CT, F, ...) \
	std::vector<T> ret; \
	CT count = 0u; \
	auto res = VKPP_CHECK(VKPP_DISPATCH(D, F, __VA_ARGS__)); \
	if(!error::success(res)) return ret; \
	ret.resize(count); \
	VKPP_CALL(D, F, __VA_ARGS__); \
	return ret;

#define VEC_FUNC_VOID(D, T, CT, F, ...) \
	std::vector<T> ret; \
	CT count = 0u; \
	VKPP_DISPATCH(D, F, __VA_ARGS__); \
	ret.resize(count); \
	VKPP_DISPATCH(D, F, __VA_ARGS__); \
	return ret;

#define VEC_FUNC_RET(D, T, C, F, ...) \
	std::vector<T> ret; \
	ret.resize(C); \
	VKPP_CALL(D, F, __VA_ARGS__); \
	return ret;

#define VEC_FUNC_RET_VOID(D, T, C, F, ...) \
	std::vector<T> ret; \
	ret.resize(C); \
	VKPP_DISPATCH(D, F, __VA_ARGS__); \
	return ret;

// global dispatch versions
#define VEC_FUNC_G(D, T, CT, F, ...) \
	std::vector<T> ret; \
	CT count = 0u; \
	auto res = VKPP_CHECK(VKPP_DISPATCH_GLOBAL(D, F, __VA_ARGS__)); \
	if(!error::success(res)) return ret; \
	ret.resize(count); \
	VKPP_CHECK(VKPP_DISPATCH_GLOBAL(D, F, __VA_ARGS__)); \
	return ret;

#define VEC_FUNC_VOID_G(D, T, CT, F, ...) \
	std::vector<T> ret; \
	CT count = 0u; \
	VKPP_DISPATCH_GLOBAL(D, F, __VA_ARGS__); \
	ret.resize(count); \
	VKPP_DISPATCH_GLOBAL(D, F, __VA_ARGS__); \
	return ret;

#define VEC_FUNC_RET_G(D, T, C, F, ...) \
	std::vector<T> ret; \
	ret.resize(C); \
	VKPP_CHECK(VKPP_DISPATCH_GLOBAL(D, F, __VA_ARGS__)); \
	return ret;

#define VEC_FUNC_RET_VOID_G(D, T, C, F, ...) \
	std::vector<T> ret; \
	ret.resize(C); \
	VKPP_DISPATCH_GLOBAL(D, F, __VA_ARGS__); \
	return ret;

namespace vk {

inline uint32_t enumerateInstanceVersion(DynamicDispatch* dispatcher = nullptr){ uint32_t ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkEnumerateInstanceVersion, (uint32_t*)(&ret))); return ret; }
inline Result bindBufferMemory2(Device device, uint32_t bindInfoCount, const BindBufferMemoryInfo& pBindInfos, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkBindBufferMemory2, (VkDevice)(device), bindInfoCount, (const VkBindBufferMemoryInfo*)(&pBindInfos)))); }
inline Result bindBufferMemory2(Device device, Span<const BindBufferMemoryInfo> pBindInfos, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkBindBufferMemory2, (VkDevice)(device), pBindInfos.size(), (const VkBindBufferMemoryInfo*)(pBindInfos.data())))); }
inline Result bindBufferMemory2KHR(Device device, uint32_t bindInfoCount, const BindBufferMemoryInfo& pBindInfos, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkBindBufferMemory2, (VkDevice)(device), bindInfoCount, (const VkBindBufferMemoryInfo*)(&pBindInfos)))); }
inline Result bindBufferMemory2KHR(Device device, Span<const BindBufferMemoryInfo> pBindInfos, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkBindBufferMemory2, (VkDevice)(device), pBindInfos.size(), (const VkBindBufferMemoryInfo*)(pBindInfos.data())))); }
inline Result bindImageMemory2(Device device, uint32_t bindInfoCount, const BindImageMemoryInfo& pBindInfos, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkBindImageMemory2, (VkDevice)(device), bindInfoCount, (const VkBindImageMemoryInfo*)(&pBindInfos)))); }
inline Result bindImageMemory2(Device device, Span<const BindImageMemoryInfo> pBindInfos, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkBindImageMemory2, (VkDevice)(device), pBindInfos.size(), (const VkBindImageMemoryInfo*)(pBindInfos.data())))); }
inline Result bindImageMemory2KHR(Device device, uint32_t bindInfoCount, const BindImageMemoryInfo& pBindInfos, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkBindImageMemory2, (VkDevice)(device), bindInfoCount, (const VkBindImageMemoryInfo*)(&pBindInfos)))); }
inline Result bindImageMemory2KHR(Device device, Span<const BindImageMemoryInfo> pBindInfos, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkBindImageMemory2, (VkDevice)(device), pBindInfos.size(), (const VkBindImageMemoryInfo*)(pBindInfos.data())))); }
inline PeerMemoryFeatureFlags getDeviceGroupPeerMemoryFeatures(Device device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, DynamicDispatch* dispatcher = nullptr){ PeerMemoryFeatureFlags ret = {}; VKPP_DISPATCH_GLOBAL(dispatcher, vkGetDeviceGroupPeerMemoryFeatures, (VkDevice)(device), heapIndex, localDeviceIndex, remoteDeviceIndex, (VkPeerMemoryFeatureFlags*)(&ret)); return ret; }
inline PeerMemoryFeatureFlags getDeviceGroupPeerMemoryFeaturesKHR(Device device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, DynamicDispatch* dispatcher = nullptr){ PeerMemoryFeatureFlags ret = {}; VKPP_DISPATCH_GLOBAL(dispatcher, vkGetDeviceGroupPeerMemoryFeatures, (VkDevice)(device), heapIndex, localDeviceIndex, remoteDeviceIndex, (VkPeerMemoryFeatureFlags*)(&ret)); return ret; }
inline void cmdSetDeviceMask(CommandBuffer commandBuffer, uint32_t deviceMask, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdSetDeviceMask, (VkCommandBuffer)(commandBuffer), deviceMask); }
inline void cmdSetDeviceMaskKHR(CommandBuffer commandBuffer, uint32_t deviceMask, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdSetDeviceMask, (VkCommandBuffer)(commandBuffer), deviceMask); }
inline void cmdDispatchBase(CommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdDispatchBase, (VkCommandBuffer)(commandBuffer), baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ); }
inline void cmdDispatchBaseKHR(CommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdDispatchBase, (VkCommandBuffer)(commandBuffer), baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ); }
inline Result enumeratePhysicalDeviceGroups(Instance instance, uint32_t& pPhysicalDeviceGroupCount, PhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties = {}, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkEnumeratePhysicalDeviceGroups, (VkInstance)(instance), (uint32_t*)(&pPhysicalDeviceGroupCount), (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties)))); }
inline std::vector<PhysicalDeviceGroupProperties> enumeratePhysicalDeviceGroups(Instance instance, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC_G(dispatcher, PhysicalDeviceGroupProperties, uint32_t, vkEnumeratePhysicalDeviceGroups, (VkInstance)(instance), &count, (VkPhysicalDeviceGroupProperties*)(ret.data()));  }
inline Result enumeratePhysicalDeviceGroupsKHR(Instance instance, uint32_t& pPhysicalDeviceGroupCount, PhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties = {}, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkEnumeratePhysicalDeviceGroups, (VkInstance)(instance), (uint32_t*)(&pPhysicalDeviceGroupCount), (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties)))); }
inline std::vector<PhysicalDeviceGroupProperties> enumeratePhysicalDeviceGroupsKHR(Instance instance, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC_G(dispatcher, PhysicalDeviceGroupProperties, uint32_t, vkEnumeratePhysicalDeviceGroups, (VkInstance)(instance), &count, (VkPhysicalDeviceGroupProperties*)(ret.data()));  }
inline MemoryRequirements2 getImageMemoryRequirements2(Device device, const ImageMemoryRequirementsInfo2& pInfo, DynamicDispatch* dispatcher = nullptr){ MemoryRequirements2 ret = {}; VKPP_DISPATCH_GLOBAL(dispatcher, vkGetImageMemoryRequirements2, (VkDevice)(device), (const VkImageMemoryRequirementsInfo2*)(&pInfo), (VkMemoryRequirements2*)(&ret)); return ret; }
inline MemoryRequirements2 getImageMemoryRequirements2KHR(Device device, const ImageMemoryRequirementsInfo2& pInfo, DynamicDispatch* dispatcher = nullptr){ MemoryRequirements2 ret = {}; VKPP_DISPATCH_GLOBAL(dispatcher, vkGetImageMemoryRequirements2, (VkDevice)(device), (const VkImageMemoryRequirementsInfo2*)(&pInfo), (VkMemoryRequirements2*)(&ret)); return ret; }
inline MemoryRequirements2 getBufferMemoryRequirements2(Device device, const BufferMemoryRequirementsInfo2& pInfo, DynamicDispatch* dispatcher = nullptr){ MemoryRequirements2 ret = {}; VKPP_DISPATCH_GLOBAL(dispatcher, vkGetBufferMemoryRequirements2, (VkDevice)(device), (const VkBufferMemoryRequirementsInfo2*)(&pInfo), (VkMemoryRequirements2*)(&ret)); return ret; }
inline MemoryRequirements2 getBufferMemoryRequirements2KHR(Device device, const BufferMemoryRequirementsInfo2& pInfo, DynamicDispatch* dispatcher = nullptr){ MemoryRequirements2 ret = {}; VKPP_DISPATCH_GLOBAL(dispatcher, vkGetBufferMemoryRequirements2, (VkDevice)(device), (const VkBufferMemoryRequirementsInfo2*)(&pInfo), (VkMemoryRequirements2*)(&ret)); return ret; }
inline void getImageSparseMemoryRequirements2(Device device, const ImageSparseMemoryRequirementsInfo2& pInfo, uint32_t& pSparseMemoryRequirementCount, SparseImageMemoryRequirements2* pSparseMemoryRequirements = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkGetImageSparseMemoryRequirements2, (VkDevice)(device), (const VkImageSparseMemoryRequirementsInfo2*)(&pInfo), (uint32_t*)(&pSparseMemoryRequirementCount), (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements)); }
inline std::vector<SparseImageMemoryRequirements2> getImageSparseMemoryRequirements2(Device device, const ImageSparseMemoryRequirementsInfo2& pInfo, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC_VOID_G(dispatcher, SparseImageMemoryRequirements2, uint32_t, vkGetImageSparseMemoryRequirements2, (VkDevice)(device), (const VkImageSparseMemoryRequirementsInfo2*)(&pInfo), &count, (VkSparseImageMemoryRequirements2*)(ret.data()));  }
inline void getImageSparseMemoryRequirements2KHR(Device device, const ImageSparseMemoryRequirementsInfo2& pInfo, uint32_t& pSparseMemoryRequirementCount, SparseImageMemoryRequirements2* pSparseMemoryRequirements = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkGetImageSparseMemoryRequirements2, (VkDevice)(device), (const VkImageSparseMemoryRequirementsInfo2*)(&pInfo), (uint32_t*)(&pSparseMemoryRequirementCount), (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements)); }
inline std::vector<SparseImageMemoryRequirements2> getImageSparseMemoryRequirements2KHR(Device device, const ImageSparseMemoryRequirementsInfo2& pInfo, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC_VOID_G(dispatcher, SparseImageMemoryRequirements2, uint32_t, vkGetImageSparseMemoryRequirements2, (VkDevice)(device), (const VkImageSparseMemoryRequirementsInfo2*)(&pInfo), &count, (VkSparseImageMemoryRequirements2*)(ret.data()));  }
inline void getPhysicalDeviceFeatures2(PhysicalDevice physicalDevice, PhysicalDeviceFeatures2& pFeatures, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPhysicalDeviceFeatures2, (VkPhysicalDevice)(physicalDevice), (VkPhysicalDeviceFeatures2*)(&pFeatures)); }
inline void getPhysicalDeviceFeatures2KHR(PhysicalDevice physicalDevice, PhysicalDeviceFeatures2& pFeatures, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPhysicalDeviceFeatures2, (VkPhysicalDevice)(physicalDevice), (VkPhysicalDeviceFeatures2*)(&pFeatures)); }
inline PhysicalDeviceProperties2 getPhysicalDeviceProperties2(PhysicalDevice physicalDevice, DynamicDispatch* dispatcher = nullptr){ PhysicalDeviceProperties2 ret = {}; VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPhysicalDeviceProperties2, (VkPhysicalDevice)(physicalDevice), (VkPhysicalDeviceProperties2*)(&ret)); return ret; }
inline PhysicalDeviceProperties2 getPhysicalDeviceProperties2KHR(PhysicalDevice physicalDevice, DynamicDispatch* dispatcher = nullptr){ PhysicalDeviceProperties2 ret = {}; VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPhysicalDeviceProperties2, (VkPhysicalDevice)(physicalDevice), (VkPhysicalDeviceProperties2*)(&ret)); return ret; }
inline FormatProperties2 getPhysicalDeviceFormatProperties2(PhysicalDevice physicalDevice, Format format, DynamicDispatch* dispatcher = nullptr){ FormatProperties2 ret = {}; VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPhysicalDeviceFormatProperties2, (VkPhysicalDevice)(physicalDevice), static_cast<VkFormat>(format), (VkFormatProperties2*)(&ret)); return ret; }
inline FormatProperties2 getPhysicalDeviceFormatProperties2KHR(PhysicalDevice physicalDevice, Format format, DynamicDispatch* dispatcher = nullptr){ FormatProperties2 ret = {}; VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPhysicalDeviceFormatProperties2, (VkPhysicalDevice)(physicalDevice), static_cast<VkFormat>(format), (VkFormatProperties2*)(&ret)); return ret; }
inline ImageFormatProperties2 getPhysicalDeviceImageFormatProperties2(PhysicalDevice physicalDevice, const PhysicalDeviceImageFormatInfo2& pImageFormatInfo, DynamicDispatch* dispatcher = nullptr){ ImageFormatProperties2 ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPhysicalDeviceImageFormatProperties2, (VkPhysicalDevice)(physicalDevice), (const VkPhysicalDeviceImageFormatInfo2*)(&pImageFormatInfo), (VkImageFormatProperties2*)(&ret))); return ret; }
inline ImageFormatProperties2 getPhysicalDeviceImageFormatProperties2KHR(PhysicalDevice physicalDevice, const PhysicalDeviceImageFormatInfo2& pImageFormatInfo, DynamicDispatch* dispatcher = nullptr){ ImageFormatProperties2 ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPhysicalDeviceImageFormatProperties2, (VkPhysicalDevice)(physicalDevice), (const VkPhysicalDeviceImageFormatInfo2*)(&pImageFormatInfo), (VkImageFormatProperties2*)(&ret))); return ret; }
inline void getPhysicalDeviceQueueFamilyProperties2(PhysicalDevice physicalDevice, uint32_t& pQueueFamilyPropertyCount, QueueFamilyProperties2* pQueueFamilyProperties = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPhysicalDeviceQueueFamilyProperties2, (VkPhysicalDevice)(physicalDevice), (uint32_t*)(&pQueueFamilyPropertyCount), (VkQueueFamilyProperties2*)(pQueueFamilyProperties)); }
inline std::vector<QueueFamilyProperties2> getPhysicalDeviceQueueFamilyProperties2(PhysicalDevice physicalDevice, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC_VOID_G(dispatcher, QueueFamilyProperties2, uint32_t, vkGetPhysicalDeviceQueueFamilyProperties2, (VkPhysicalDevice)(physicalDevice), &count, (VkQueueFamilyProperties2*)(ret.data()));  }
inline void getPhysicalDeviceQueueFamilyProperties2KHR(PhysicalDevice physicalDevice, uint32_t& pQueueFamilyPropertyCount, QueueFamilyProperties2* pQueueFamilyProperties = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPhysicalDeviceQueueFamilyProperties2, (VkPhysicalDevice)(physicalDevice), (uint32_t*)(&pQueueFamilyPropertyCount), (VkQueueFamilyProperties2*)(pQueueFamilyProperties)); }
inline std::vector<QueueFamilyProperties2> getPhysicalDeviceQueueFamilyProperties2KHR(PhysicalDevice physicalDevice, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC_VOID_G(dispatcher, QueueFamilyProperties2, uint32_t, vkGetPhysicalDeviceQueueFamilyProperties2, (VkPhysicalDevice)(physicalDevice), &count, (VkQueueFamilyProperties2*)(ret.data()));  }
inline PhysicalDeviceMemoryProperties2 getPhysicalDeviceMemoryProperties2(PhysicalDevice physicalDevice, DynamicDispatch* dispatcher = nullptr){ PhysicalDeviceMemoryProperties2 ret = {}; VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPhysicalDeviceMemoryProperties2, (VkPhysicalDevice)(physicalDevice), (VkPhysicalDeviceMemoryProperties2*)(&ret)); return ret; }
inline PhysicalDeviceMemoryProperties2 getPhysicalDeviceMemoryProperties2KHR(PhysicalDevice physicalDevice, DynamicDispatch* dispatcher = nullptr){ PhysicalDeviceMemoryProperties2 ret = {}; VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPhysicalDeviceMemoryProperties2, (VkPhysicalDevice)(physicalDevice), (VkPhysicalDeviceMemoryProperties2*)(&ret)); return ret; }
inline void getPhysicalDeviceSparseImageFormatProperties2(PhysicalDevice physicalDevice, const PhysicalDeviceSparseImageFormatInfo2& pFormatInfo, uint32_t& pPropertyCount, SparseImageFormatProperties2* pProperties = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPhysicalDeviceSparseImageFormatProperties2, (VkPhysicalDevice)(physicalDevice), (const VkPhysicalDeviceSparseImageFormatInfo2*)(&pFormatInfo), (uint32_t*)(&pPropertyCount), (VkSparseImageFormatProperties2*)(pProperties)); }
inline std::vector<SparseImageFormatProperties2> getPhysicalDeviceSparseImageFormatProperties2(PhysicalDevice physicalDevice, const PhysicalDeviceSparseImageFormatInfo2& pFormatInfo, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC_VOID_G(dispatcher, SparseImageFormatProperties2, uint32_t, vkGetPhysicalDeviceSparseImageFormatProperties2, (VkPhysicalDevice)(physicalDevice), (const VkPhysicalDeviceSparseImageFormatInfo2*)(&pFormatInfo), &count, (VkSparseImageFormatProperties2*)(ret.data()));  }
inline void getPhysicalDeviceSparseImageFormatProperties2KHR(PhysicalDevice physicalDevice, const PhysicalDeviceSparseImageFormatInfo2& pFormatInfo, uint32_t& pPropertyCount, SparseImageFormatProperties2* pProperties = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPhysicalDeviceSparseImageFormatProperties2, (VkPhysicalDevice)(physicalDevice), (const VkPhysicalDeviceSparseImageFormatInfo2*)(&pFormatInfo), (uint32_t*)(&pPropertyCount), (VkSparseImageFormatProperties2*)(pProperties)); }
inline std::vector<SparseImageFormatProperties2> getPhysicalDeviceSparseImageFormatProperties2KHR(PhysicalDevice physicalDevice, const PhysicalDeviceSparseImageFormatInfo2& pFormatInfo, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC_VOID_G(dispatcher, SparseImageFormatProperties2, uint32_t, vkGetPhysicalDeviceSparseImageFormatProperties2, (VkPhysicalDevice)(physicalDevice), (const VkPhysicalDeviceSparseImageFormatInfo2*)(&pFormatInfo), &count, (VkSparseImageFormatProperties2*)(ret.data()));  }
inline void trimCommandPool(Device device, CommandPool commandPool, CommandPoolTrimFlags flags = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkTrimCommandPool, (VkDevice)(device), (VkCommandPool)(commandPool), static_cast<VkCommandPoolTrimFlags>(flags)); }
inline void trimCommandPoolKHR(Device device, CommandPool commandPool, CommandPoolTrimFlags flags = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkTrimCommandPool, (VkDevice)(device), (VkCommandPool)(commandPool), static_cast<VkCommandPoolTrimFlags>(flags)); }
inline Queue getDeviceQueue2(Device device, const DeviceQueueInfo2& pQueueInfo, DynamicDispatch* dispatcher = nullptr){ Queue ret = {}; VKPP_DISPATCH_GLOBAL(dispatcher, vkGetDeviceQueue2, (VkDevice)(device), (const VkDeviceQueueInfo2*)(&pQueueInfo), (VkQueue*)(&ret)); return ret; }
inline SamplerYcbcrConversion createSamplerYcbcrConversion(Device device, const SamplerYcbcrConversionCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ SamplerYcbcrConversion ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkCreateSamplerYcbcrConversion, (VkDevice)(device), (const VkSamplerYcbcrConversionCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkSamplerYcbcrConversion*)(&ret))); return ret; }
inline SamplerYcbcrConversion createSamplerYcbcrConversionKHR(Device device, const SamplerYcbcrConversionCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ SamplerYcbcrConversion ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkCreateSamplerYcbcrConversion, (VkDevice)(device), (const VkSamplerYcbcrConversionCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkSamplerYcbcrConversion*)(&ret))); return ret; }
inline void destroySamplerYcbcrConversion(Device device, SamplerYcbcrConversion ycbcrConversion = {}, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkDestroySamplerYcbcrConversion, (VkDevice)(device), (VkSamplerYcbcrConversion)(ycbcrConversion), (const VkAllocationCallbacks*)(pAllocator)); }
inline void destroySamplerYcbcrConversionKHR(Device device, SamplerYcbcrConversion ycbcrConversion = {}, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkDestroySamplerYcbcrConversion, (VkDevice)(device), (VkSamplerYcbcrConversion)(ycbcrConversion), (const VkAllocationCallbacks*)(pAllocator)); }
inline DescriptorUpdateTemplate createDescriptorUpdateTemplate(Device device, const DescriptorUpdateTemplateCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ DescriptorUpdateTemplate ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkCreateDescriptorUpdateTemplate, (VkDevice)(device), (const VkDescriptorUpdateTemplateCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkDescriptorUpdateTemplate*)(&ret))); return ret; }
inline DescriptorUpdateTemplate createDescriptorUpdateTemplateKHR(Device device, const DescriptorUpdateTemplateCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ DescriptorUpdateTemplate ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkCreateDescriptorUpdateTemplate, (VkDevice)(device), (const VkDescriptorUpdateTemplateCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkDescriptorUpdateTemplate*)(&ret))); return ret; }
inline void destroyDescriptorUpdateTemplate(Device device, DescriptorUpdateTemplate descriptorUpdateTemplate = {}, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkDestroyDescriptorUpdateTemplate, (VkDevice)(device), (VkDescriptorUpdateTemplate)(descriptorUpdateTemplate), (const VkAllocationCallbacks*)(pAllocator)); }
inline void destroyDescriptorUpdateTemplateKHR(Device device, DescriptorUpdateTemplate descriptorUpdateTemplate = {}, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkDestroyDescriptorUpdateTemplate, (VkDevice)(device), (VkDescriptorUpdateTemplate)(descriptorUpdateTemplate), (const VkAllocationCallbacks*)(pAllocator)); }
inline void updateDescriptorSetWithTemplate(Device device, DescriptorSet descriptorSet, DescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkUpdateDescriptorSetWithTemplate, (VkDevice)(device), (VkDescriptorSet)(descriptorSet), (VkDescriptorUpdateTemplate)(descriptorUpdateTemplate), (const void*)(pData)); }
inline void updateDescriptorSetWithTemplateKHR(Device device, DescriptorSet descriptorSet, DescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkUpdateDescriptorSetWithTemplate, (VkDevice)(device), (VkDescriptorSet)(descriptorSet), (VkDescriptorUpdateTemplate)(descriptorUpdateTemplate), (const void*)(pData)); }
inline ExternalBufferProperties getPhysicalDeviceExternalBufferProperties(PhysicalDevice physicalDevice, const PhysicalDeviceExternalBufferInfo& pExternalBufferInfo, DynamicDispatch* dispatcher = nullptr){ ExternalBufferProperties ret = {}; VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPhysicalDeviceExternalBufferProperties, (VkPhysicalDevice)(physicalDevice), (const VkPhysicalDeviceExternalBufferInfo*)(&pExternalBufferInfo), (VkExternalBufferProperties*)(&ret)); return ret; }
inline ExternalBufferProperties getPhysicalDeviceExternalBufferPropertiesKHR(PhysicalDevice physicalDevice, const PhysicalDeviceExternalBufferInfo& pExternalBufferInfo, DynamicDispatch* dispatcher = nullptr){ ExternalBufferProperties ret = {}; VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPhysicalDeviceExternalBufferProperties, (VkPhysicalDevice)(physicalDevice), (const VkPhysicalDeviceExternalBufferInfo*)(&pExternalBufferInfo), (VkExternalBufferProperties*)(&ret)); return ret; }
inline ExternalFenceProperties getPhysicalDeviceExternalFenceProperties(PhysicalDevice physicalDevice, const PhysicalDeviceExternalFenceInfo& pExternalFenceInfo, DynamicDispatch* dispatcher = nullptr){ ExternalFenceProperties ret = {}; VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPhysicalDeviceExternalFenceProperties, (VkPhysicalDevice)(physicalDevice), (const VkPhysicalDeviceExternalFenceInfo*)(&pExternalFenceInfo), (VkExternalFenceProperties*)(&ret)); return ret; }
inline ExternalFenceProperties getPhysicalDeviceExternalFencePropertiesKHR(PhysicalDevice physicalDevice, const PhysicalDeviceExternalFenceInfo& pExternalFenceInfo, DynamicDispatch* dispatcher = nullptr){ ExternalFenceProperties ret = {}; VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPhysicalDeviceExternalFenceProperties, (VkPhysicalDevice)(physicalDevice), (const VkPhysicalDeviceExternalFenceInfo*)(&pExternalFenceInfo), (VkExternalFenceProperties*)(&ret)); return ret; }
inline ExternalSemaphoreProperties getPhysicalDeviceExternalSemaphoreProperties(PhysicalDevice physicalDevice, const PhysicalDeviceExternalSemaphoreInfo& pExternalSemaphoreInfo, DynamicDispatch* dispatcher = nullptr){ ExternalSemaphoreProperties ret = {}; VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPhysicalDeviceExternalSemaphoreProperties, (VkPhysicalDevice)(physicalDevice), (const VkPhysicalDeviceExternalSemaphoreInfo*)(&pExternalSemaphoreInfo), (VkExternalSemaphoreProperties*)(&ret)); return ret; }
inline ExternalSemaphoreProperties getPhysicalDeviceExternalSemaphorePropertiesKHR(PhysicalDevice physicalDevice, const PhysicalDeviceExternalSemaphoreInfo& pExternalSemaphoreInfo, DynamicDispatch* dispatcher = nullptr){ ExternalSemaphoreProperties ret = {}; VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPhysicalDeviceExternalSemaphoreProperties, (VkPhysicalDevice)(physicalDevice), (const VkPhysicalDeviceExternalSemaphoreInfo*)(&pExternalSemaphoreInfo), (VkExternalSemaphoreProperties*)(&ret)); return ret; }
inline DescriptorSetLayoutSupport getDescriptorSetLayoutSupport(Device device, const DescriptorSetLayoutCreateInfo& pCreateInfo, DynamicDispatch* dispatcher = nullptr){ DescriptorSetLayoutSupport ret = {}; VKPP_DISPATCH_GLOBAL(dispatcher, vkGetDescriptorSetLayoutSupport, (VkDevice)(device), (const VkDescriptorSetLayoutCreateInfo*)(&pCreateInfo), (VkDescriptorSetLayoutSupport*)(&ret)); return ret; }
inline DescriptorSetLayoutSupport getDescriptorSetLayoutSupportKHR(Device device, const DescriptorSetLayoutCreateInfo& pCreateInfo, DynamicDispatch* dispatcher = nullptr){ DescriptorSetLayoutSupport ret = {}; VKPP_DISPATCH_GLOBAL(dispatcher, vkGetDescriptorSetLayoutSupport, (VkDevice)(device), (const VkDescriptorSetLayoutCreateInfo*)(&pCreateInfo), (VkDescriptorSetLayoutSupport*)(&ret)); return ret; }

inline Instance createInstance(const InstanceCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ Instance ret = {}; VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkCreateInstance, (const VkInstanceCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkInstance*)(&ret))); return ret; }
inline void destroyInstance(Instance instance = {}, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkDestroyInstance, (VkInstance)(instance), (const VkAllocationCallbacks*)(pAllocator)); }
inline Result enumeratePhysicalDevices(Instance instance, uint32_t& pPhysicalDeviceCount, PhysicalDevice* pPhysicalDevices = {}, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkEnumeratePhysicalDevices, (VkInstance)(instance), (uint32_t*)(&pPhysicalDeviceCount), (VkPhysicalDevice*)(pPhysicalDevices)))); }
inline std::vector<PhysicalDevice> enumeratePhysicalDevices(Instance instance, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC(dispatcher, PhysicalDevice, uint32_t, vkEnumeratePhysicalDevices, (VkInstance)(instance), &count, (VkPhysicalDevice*)(ret.data()));  }
inline void getPhysicalDeviceFeatures(PhysicalDevice physicalDevice, PhysicalDeviceFeatures& pFeatures, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkGetPhysicalDeviceFeatures, (VkPhysicalDevice)(physicalDevice), (VkPhysicalDeviceFeatures*)(&pFeatures)); }
inline FormatProperties getPhysicalDeviceFormatProperties(PhysicalDevice physicalDevice, Format format, DynamicDispatch* dispatcher = nullptr){ FormatProperties ret = {}; VKPP_DISPATCH(dispatcher, vkGetPhysicalDeviceFormatProperties, (VkPhysicalDevice)(physicalDevice), static_cast<VkFormat>(format), (VkFormatProperties*)(&ret)); return ret; }
inline ImageFormatProperties getPhysicalDeviceImageFormatProperties(PhysicalDevice physicalDevice, Format format, ImageType type, ImageTiling tiling, ImageUsageFlags usage, ImageCreateFlags flags = {}, DynamicDispatch* dispatcher = nullptr){ ImageFormatProperties ret = {}; VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkGetPhysicalDeviceImageFormatProperties, (VkPhysicalDevice)(physicalDevice), static_cast<VkFormat>(format), static_cast<VkImageType>(type), static_cast<VkImageTiling>(tiling), static_cast<VkImageUsageFlags>(usage), static_cast<VkImageCreateFlags>(flags), (VkImageFormatProperties*)(&ret))); return ret; }
inline PhysicalDeviceProperties getPhysicalDeviceProperties(PhysicalDevice physicalDevice, DynamicDispatch* dispatcher = nullptr){ PhysicalDeviceProperties ret = {}; VKPP_DISPATCH(dispatcher, vkGetPhysicalDeviceProperties, (VkPhysicalDevice)(physicalDevice), (VkPhysicalDeviceProperties*)(&ret)); return ret; }
inline void getPhysicalDeviceQueueFamilyProperties(PhysicalDevice physicalDevice, uint32_t& pQueueFamilyPropertyCount, QueueFamilyProperties* pQueueFamilyProperties = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkGetPhysicalDeviceQueueFamilyProperties, (VkPhysicalDevice)(physicalDevice), (uint32_t*)(&pQueueFamilyPropertyCount), (VkQueueFamilyProperties*)(pQueueFamilyProperties)); }
inline std::vector<QueueFamilyProperties> getPhysicalDeviceQueueFamilyProperties(PhysicalDevice physicalDevice, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC_VOID(dispatcher, QueueFamilyProperties, uint32_t, vkGetPhysicalDeviceQueueFamilyProperties, (VkPhysicalDevice)(physicalDevice), &count, (VkQueueFamilyProperties*)(ret.data()));  }
inline PhysicalDeviceMemoryProperties getPhysicalDeviceMemoryProperties(PhysicalDevice physicalDevice, DynamicDispatch* dispatcher = nullptr){ PhysicalDeviceMemoryProperties ret = {}; VKPP_DISPATCH(dispatcher, vkGetPhysicalDeviceMemoryProperties, (VkPhysicalDevice)(physicalDevice), (VkPhysicalDeviceMemoryProperties*)(&ret)); return ret; }
inline PFN_vkVoidFunction getInstanceProcAddr(Instance instance, const char* pName, DynamicDispatch* dispatcher = nullptr){ return static_cast<PFN_vkVoidFunction>(VKPP_DISPATCH(dispatcher, vkGetInstanceProcAddr, (VkInstance)(instance), (const char*)(pName))); }
inline PFN_vkVoidFunction getDeviceProcAddr(Device device, const char* pName, DynamicDispatch* dispatcher = nullptr){ return static_cast<PFN_vkVoidFunction>(VKPP_DISPATCH(dispatcher, vkGetDeviceProcAddr, (VkDevice)(device), (const char*)(pName))); }
inline Device createDevice(PhysicalDevice physicalDevice, const DeviceCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ Device ret = {}; VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkCreateDevice, (VkPhysicalDevice)(physicalDevice), (const VkDeviceCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkDevice*)(&ret))); return ret; }
inline void destroyDevice(Device device = {}, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkDestroyDevice, (VkDevice)(device), (const VkAllocationCallbacks*)(pAllocator)); }
inline Result enumerateInstanceExtensionProperties(const char* pLayerName, uint32_t& pPropertyCount, ExtensionProperties* pProperties = {}, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkEnumerateInstanceExtensionProperties, (const char*)(pLayerName), (uint32_t*)(&pPropertyCount), (VkExtensionProperties*)(pProperties)))); }
inline std::vector<ExtensionProperties> enumerateInstanceExtensionProperties(const char* pLayerName, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC(dispatcher, ExtensionProperties, uint32_t, vkEnumerateInstanceExtensionProperties, (const char*)(pLayerName), &count, (VkExtensionProperties*)(ret.data()));  }
inline Result enumerateDeviceExtensionProperties(PhysicalDevice physicalDevice, const char* pLayerName, uint32_t& pPropertyCount, ExtensionProperties* pProperties = {}, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkEnumerateDeviceExtensionProperties, (VkPhysicalDevice)(physicalDevice), (const char*)(pLayerName), (uint32_t*)(&pPropertyCount), (VkExtensionProperties*)(pProperties)))); }
inline std::vector<ExtensionProperties> enumerateDeviceExtensionProperties(PhysicalDevice physicalDevice, const char* pLayerName, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC(dispatcher, ExtensionProperties, uint32_t, vkEnumerateDeviceExtensionProperties, (VkPhysicalDevice)(physicalDevice), (const char*)(pLayerName), &count, (VkExtensionProperties*)(ret.data()));  }
inline Result enumerateInstanceLayerProperties(uint32_t& pPropertyCount, LayerProperties* pProperties = {}, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkEnumerateInstanceLayerProperties, (uint32_t*)(&pPropertyCount), (VkLayerProperties*)(pProperties)))); }
inline std::vector<LayerProperties> enumerateInstanceLayerProperties(DynamicDispatch* dispatcher = nullptr){ VEC_FUNC(dispatcher, LayerProperties, uint32_t, vkEnumerateInstanceLayerProperties, &count, (VkLayerProperties*)(ret.data()));  }
inline Result enumerateDeviceLayerProperties(PhysicalDevice physicalDevice, uint32_t& pPropertyCount, LayerProperties* pProperties = {}, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkEnumerateDeviceLayerProperties, (VkPhysicalDevice)(physicalDevice), (uint32_t*)(&pPropertyCount), (VkLayerProperties*)(pProperties)))); }
inline std::vector<LayerProperties> enumerateDeviceLayerProperties(PhysicalDevice physicalDevice, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC(dispatcher, LayerProperties, uint32_t, vkEnumerateDeviceLayerProperties, (VkPhysicalDevice)(physicalDevice), &count, (VkLayerProperties*)(ret.data()));  }
inline Queue getDeviceQueue(Device device, uint32_t queueFamilyIndex, uint32_t queueIndex, DynamicDispatch* dispatcher = nullptr){ Queue ret = {}; VKPP_DISPATCH(dispatcher, vkGetDeviceQueue, (VkDevice)(device), queueFamilyIndex, queueIndex, (VkQueue*)(&ret)); return ret; }
inline Result queueSubmit(Queue queue, uint32_t submitCount, const SubmitInfo& pSubmits, Fence fence = {}, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkQueueSubmit, (VkQueue)(queue), submitCount, (const VkSubmitInfo*)(&pSubmits), (VkFence)(fence)))); }
inline Result queueSubmit(Queue queue, Span<const SubmitInfo> pSubmits, Fence fence = {}, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkQueueSubmit, (VkQueue)(queue), pSubmits.size(), (const VkSubmitInfo*)(pSubmits.data()), (VkFence)(fence)))); }
inline Result queueWaitIdle(Queue queue, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkQueueWaitIdle, (VkQueue)(queue)))); }
inline Result deviceWaitIdle(Device device, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkDeviceWaitIdle, (VkDevice)(device)))); }
inline DeviceMemory allocateMemory(Device device, const MemoryAllocateInfo& pAllocateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ DeviceMemory ret = {}; VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkAllocateMemory, (VkDevice)(device), (const VkMemoryAllocateInfo*)(&pAllocateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkDeviceMemory*)(&ret))); return ret; }
inline void freeMemory(Device device, DeviceMemory memory = {}, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkFreeMemory, (VkDevice)(device), (VkDeviceMemory)(memory), (const VkAllocationCallbacks*)(pAllocator)); }
inline void* mapMemory(Device device, DeviceMemory memory, DeviceSize offset, DeviceSize size, MemoryMapFlags flags = {}, DynamicDispatch* dispatcher = nullptr){ void* ret = {}; VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkMapMemory, (VkDevice)(device), (VkDeviceMemory)(memory), offset, size, static_cast<VkMemoryMapFlags>(flags), (void**)(&ret))); return ret; }
inline void unmapMemory(Device device, DeviceMemory memory, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkUnmapMemory, (VkDevice)(device), (VkDeviceMemory)(memory)); }
inline Result flushMappedMemoryRanges(Device device, uint32_t memoryRangeCount, const MappedMemoryRange& pMemoryRanges, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkFlushMappedMemoryRanges, (VkDevice)(device), memoryRangeCount, (const VkMappedMemoryRange*)(&pMemoryRanges)))); }
inline Result flushMappedMemoryRanges(Device device, Span<const MappedMemoryRange> pMemoryRanges, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkFlushMappedMemoryRanges, (VkDevice)(device), pMemoryRanges.size(), (const VkMappedMemoryRange*)(pMemoryRanges.data())))); }
inline Result invalidateMappedMemoryRanges(Device device, uint32_t memoryRangeCount, const MappedMemoryRange& pMemoryRanges, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkInvalidateMappedMemoryRanges, (VkDevice)(device), memoryRangeCount, (const VkMappedMemoryRange*)(&pMemoryRanges)))); }
inline Result invalidateMappedMemoryRanges(Device device, Span<const MappedMemoryRange> pMemoryRanges, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkInvalidateMappedMemoryRanges, (VkDevice)(device), pMemoryRanges.size(), (const VkMappedMemoryRange*)(pMemoryRanges.data())))); }
inline DeviceSize getDeviceMemoryCommitment(Device device, DeviceMemory memory, DynamicDispatch* dispatcher = nullptr){ DeviceSize ret = {}; VKPP_DISPATCH(dispatcher, vkGetDeviceMemoryCommitment, (VkDevice)(device), (VkDeviceMemory)(memory), (VkDeviceSize*)(&ret)); return ret; }
inline Result bindBufferMemory(Device device, Buffer buffer, DeviceMemory memory, DeviceSize memoryOffset, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkBindBufferMemory, (VkDevice)(device), (VkBuffer)(buffer), (VkDeviceMemory)(memory), memoryOffset))); }
inline Result bindImageMemory(Device device, Image image, DeviceMemory memory, DeviceSize memoryOffset, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkBindImageMemory, (VkDevice)(device), (VkImage)(image), (VkDeviceMemory)(memory), memoryOffset))); }
inline MemoryRequirements getBufferMemoryRequirements(Device device, Buffer buffer, DynamicDispatch* dispatcher = nullptr){ MemoryRequirements ret = {}; VKPP_DISPATCH(dispatcher, vkGetBufferMemoryRequirements, (VkDevice)(device), (VkBuffer)(buffer), (VkMemoryRequirements*)(&ret)); return ret; }
inline MemoryRequirements getImageMemoryRequirements(Device device, Image image, DynamicDispatch* dispatcher = nullptr){ MemoryRequirements ret = {}; VKPP_DISPATCH(dispatcher, vkGetImageMemoryRequirements, (VkDevice)(device), (VkImage)(image), (VkMemoryRequirements*)(&ret)); return ret; }
inline void getImageSparseMemoryRequirements(Device device, Image image, uint32_t& pSparseMemoryRequirementCount, SparseImageMemoryRequirements* pSparseMemoryRequirements = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkGetImageSparseMemoryRequirements, (VkDevice)(device), (VkImage)(image), (uint32_t*)(&pSparseMemoryRequirementCount), (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements)); }
inline std::vector<SparseImageMemoryRequirements> getImageSparseMemoryRequirements(Device device, Image image, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC_VOID(dispatcher, SparseImageMemoryRequirements, uint32_t, vkGetImageSparseMemoryRequirements, (VkDevice)(device), (VkImage)(image), &count, (VkSparseImageMemoryRequirements*)(ret.data()));  }
inline void getPhysicalDeviceSparseImageFormatProperties(PhysicalDevice physicalDevice, Format format, ImageType type, SampleCountBits samples, ImageUsageFlags usage, ImageTiling tiling, uint32_t& pPropertyCount, SparseImageFormatProperties* pProperties = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkGetPhysicalDeviceSparseImageFormatProperties, (VkPhysicalDevice)(physicalDevice), static_cast<VkFormat>(format), static_cast<VkImageType>(type), static_cast<VkSampleCountFlagBits>(samples), static_cast<VkImageUsageFlags>(usage), static_cast<VkImageTiling>(tiling), (uint32_t*)(&pPropertyCount), (VkSparseImageFormatProperties*)(pProperties)); }
inline std::vector<SparseImageFormatProperties> getPhysicalDeviceSparseImageFormatProperties(PhysicalDevice physicalDevice, Format format, ImageType type, SampleCountBits samples, ImageUsageFlags usage, ImageTiling tiling, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC_VOID(dispatcher, SparseImageFormatProperties, uint32_t, vkGetPhysicalDeviceSparseImageFormatProperties, (VkPhysicalDevice)(physicalDevice), static_cast<VkFormat>(format), static_cast<VkImageType>(type), static_cast<VkSampleCountFlagBits>(samples), static_cast<VkImageUsageFlags>(usage), static_cast<VkImageTiling>(tiling), &count, (VkSparseImageFormatProperties*)(ret.data()));  }
inline Result queueBindSparse(Queue queue, uint32_t bindInfoCount, const BindSparseInfo& pBindInfo, Fence fence = {}, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkQueueBindSparse, (VkQueue)(queue), bindInfoCount, (const VkBindSparseInfo*)(&pBindInfo), (VkFence)(fence)))); }
inline Result queueBindSparse(Queue queue, Span<const BindSparseInfo> pBindInfo, Fence fence = {}, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkQueueBindSparse, (VkQueue)(queue), pBindInfo.size(), (const VkBindSparseInfo*)(pBindInfo.data()), (VkFence)(fence)))); }
inline Fence createFence(Device device, const FenceCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ Fence ret = {}; VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkCreateFence, (VkDevice)(device), (const VkFenceCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkFence*)(&ret))); return ret; }
inline void destroyFence(Device device, Fence fence = {}, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkDestroyFence, (VkDevice)(device), (VkFence)(fence), (const VkAllocationCallbacks*)(pAllocator)); }
inline Result resetFences(Device device, uint32_t fenceCount, const Fence& pFences, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkResetFences, (VkDevice)(device), fenceCount, (const VkFence*)(&pFences)))); }
inline Result resetFences(Device device, Span<const Fence> pFences, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkResetFences, (VkDevice)(device), pFences.size(), (const VkFence*)(pFences.data())))); }
inline Result getFenceStatus(Device device, Fence fence, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkGetFenceStatus, (VkDevice)(device), (VkFence)(fence)))); }
inline Result waitForFences(Device device, uint32_t fenceCount, const Fence& pFences, Bool32 waitAll, uint64_t timeout, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkWaitForFences, (VkDevice)(device), fenceCount, (const VkFence*)(&pFences), waitAll, timeout))); }
inline Result waitForFences(Device device, Span<const Fence> pFences, Bool32 waitAll, uint64_t timeout, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkWaitForFences, (VkDevice)(device), pFences.size(), (const VkFence*)(pFences.data()), waitAll, timeout))); }
inline Semaphore createSemaphore(Device device, const SemaphoreCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ Semaphore ret = {}; VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkCreateSemaphore, (VkDevice)(device), (const VkSemaphoreCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkSemaphore*)(&ret))); return ret; }
inline void destroySemaphore(Device device, Semaphore semaphore = {}, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkDestroySemaphore, (VkDevice)(device), (VkSemaphore)(semaphore), (const VkAllocationCallbacks*)(pAllocator)); }
inline Event createEvent(Device device, const EventCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ Event ret = {}; VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkCreateEvent, (VkDevice)(device), (const VkEventCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkEvent*)(&ret))); return ret; }
inline void destroyEvent(Device device, Event event = {}, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkDestroyEvent, (VkDevice)(device), (VkEvent)(event), (const VkAllocationCallbacks*)(pAllocator)); }
inline Result getEventStatus(Device device, Event event, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkGetEventStatus, (VkDevice)(device), (VkEvent)(event)))); }
inline Result setEvent(Device device, Event event, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkSetEvent, (VkDevice)(device), (VkEvent)(event)))); }
inline Result resetEvent(Device device, Event event, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkResetEvent, (VkDevice)(device), (VkEvent)(event)))); }
inline QueryPool createQueryPool(Device device, const QueryPoolCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ QueryPool ret = {}; VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkCreateQueryPool, (VkDevice)(device), (const VkQueryPoolCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkQueryPool*)(&ret))); return ret; }
inline void destroyQueryPool(Device device, QueryPool queryPool = {}, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkDestroyQueryPool, (VkDevice)(device), (VkQueryPool)(queryPool), (const VkAllocationCallbacks*)(pAllocator)); }
inline Result getQueryPoolResults(Device device, QueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, size_t dataSize, void* pData, DeviceSize stride, QueryResultFlags flags = {}, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkGetQueryPoolResults, (VkDevice)(device), (VkQueryPool)(queryPool), firstQuery, queryCount, dataSize, (void*)(pData), stride, static_cast<VkQueryResultFlags>(flags)))); }
inline std::vector<uint8_t> getQueryPoolResults(Device device, QueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, size_t dataSize, DeviceSize stride, QueryResultFlags flags = {}, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC_RET(dispatcher, uint8_t, dataSize, vkGetQueryPoolResults, (VkDevice)(device), (VkQueryPool)(queryPool), firstQuery, queryCount, dataSize, (void*)(ret.data()), stride, static_cast<VkQueryResultFlags>(flags));  }
inline Buffer createBuffer(Device device, const BufferCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ Buffer ret = {}; VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkCreateBuffer, (VkDevice)(device), (const VkBufferCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkBuffer*)(&ret))); return ret; }
inline void destroyBuffer(Device device, Buffer buffer = {}, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkDestroyBuffer, (VkDevice)(device), (VkBuffer)(buffer), (const VkAllocationCallbacks*)(pAllocator)); }
inline BufferView createBufferView(Device device, const BufferViewCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ BufferView ret = {}; VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkCreateBufferView, (VkDevice)(device), (const VkBufferViewCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkBufferView*)(&ret))); return ret; }
inline void destroyBufferView(Device device, BufferView bufferView = {}, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkDestroyBufferView, (VkDevice)(device), (VkBufferView)(bufferView), (const VkAllocationCallbacks*)(pAllocator)); }
inline Image createImage(Device device, const ImageCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ Image ret = {}; VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkCreateImage, (VkDevice)(device), (const VkImageCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkImage*)(&ret))); return ret; }
inline void destroyImage(Device device, Image image = {}, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkDestroyImage, (VkDevice)(device), (VkImage)(image), (const VkAllocationCallbacks*)(pAllocator)); }
inline SubresourceLayout getImageSubresourceLayout(Device device, Image image, const ImageSubresource& pSubresource, DynamicDispatch* dispatcher = nullptr){ SubresourceLayout ret = {}; VKPP_DISPATCH(dispatcher, vkGetImageSubresourceLayout, (VkDevice)(device), (VkImage)(image), (const VkImageSubresource*)(&pSubresource), (VkSubresourceLayout*)(&ret)); return ret; }
inline ImageView createImageView(Device device, const ImageViewCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ ImageView ret = {}; VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkCreateImageView, (VkDevice)(device), (const VkImageViewCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkImageView*)(&ret))); return ret; }
inline void destroyImageView(Device device, ImageView imageView = {}, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkDestroyImageView, (VkDevice)(device), (VkImageView)(imageView), (const VkAllocationCallbacks*)(pAllocator)); }
inline ShaderModule createShaderModule(Device device, const ShaderModuleCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ ShaderModule ret = {}; VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkCreateShaderModule, (VkDevice)(device), (const VkShaderModuleCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkShaderModule*)(&ret))); return ret; }
inline void destroyShaderModule(Device device, ShaderModule shaderModule = {}, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkDestroyShaderModule, (VkDevice)(device), (VkShaderModule)(shaderModule), (const VkAllocationCallbacks*)(pAllocator)); }
inline PipelineCache createPipelineCache(Device device, const PipelineCacheCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ PipelineCache ret = {}; VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkCreatePipelineCache, (VkDevice)(device), (const VkPipelineCacheCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkPipelineCache*)(&ret))); return ret; }
inline void destroyPipelineCache(Device device, PipelineCache pipelineCache = {}, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkDestroyPipelineCache, (VkDevice)(device), (VkPipelineCache)(pipelineCache), (const VkAllocationCallbacks*)(pAllocator)); }
inline Result getPipelineCacheData(Device device, PipelineCache pipelineCache, size_t& pDataSize, void* pData = {}, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkGetPipelineCacheData, (VkDevice)(device), (VkPipelineCache)(pipelineCache), (size_t*)(&pDataSize), (void*)(pData)))); }
inline std::vector<uint8_t> getPipelineCacheData(Device device, PipelineCache pipelineCache, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC(dispatcher, uint8_t, size_t, vkGetPipelineCacheData, (VkDevice)(device), (VkPipelineCache)(pipelineCache), &count, (void*)(ret.data()));  }
inline Result mergePipelineCaches(Device device, PipelineCache dstCache, uint32_t srcCacheCount, const PipelineCache& pSrcCaches, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkMergePipelineCaches, (VkDevice)(device), (VkPipelineCache)(dstCache), srcCacheCount, (const VkPipelineCache*)(&pSrcCaches)))); }
inline Result mergePipelineCaches(Device device, PipelineCache dstCache, Span<const PipelineCache> pSrcCaches, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkMergePipelineCaches, (VkDevice)(device), (VkPipelineCache)(dstCache), pSrcCaches.size(), (const VkPipelineCache*)(pSrcCaches.data())))); }
inline Result createGraphicsPipelines(Device device, PipelineCache pipelineCache, uint32_t createInfoCount, const GraphicsPipelineCreateInfo& pCreateInfos, const AllocationCallbacks* pAllocator, Pipeline& pPipelines, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkCreateGraphicsPipelines, (VkDevice)(device), (VkPipelineCache)(pipelineCache), createInfoCount, (const VkGraphicsPipelineCreateInfo*)(&pCreateInfos), (const VkAllocationCallbacks*)(pAllocator), (VkPipeline*)(&pPipelines)))); }
inline std::vector<Pipeline> createGraphicsPipelines(Device device, PipelineCache pipelineCache, Span<const GraphicsPipelineCreateInfo> pCreateInfos, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC_RET(dispatcher, Pipeline, pCreateInfos.size(), vkCreateGraphicsPipelines, (VkDevice)(device), (VkPipelineCache)(pipelineCache), pCreateInfos.size(), (const VkGraphicsPipelineCreateInfo*)(pCreateInfos.data()), (const VkAllocationCallbacks*)(pAllocator), (VkPipeline*)(ret.data()));  }
inline Result createComputePipelines(Device device, PipelineCache pipelineCache, uint32_t createInfoCount, const ComputePipelineCreateInfo& pCreateInfos, const AllocationCallbacks* pAllocator, Pipeline& pPipelines, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkCreateComputePipelines, (VkDevice)(device), (VkPipelineCache)(pipelineCache), createInfoCount, (const VkComputePipelineCreateInfo*)(&pCreateInfos), (const VkAllocationCallbacks*)(pAllocator), (VkPipeline*)(&pPipelines)))); }
inline std::vector<Pipeline> createComputePipelines(Device device, PipelineCache pipelineCache, Span<const ComputePipelineCreateInfo> pCreateInfos, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC_RET(dispatcher, Pipeline, pCreateInfos.size(), vkCreateComputePipelines, (VkDevice)(device), (VkPipelineCache)(pipelineCache), pCreateInfos.size(), (const VkComputePipelineCreateInfo*)(pCreateInfos.data()), (const VkAllocationCallbacks*)(pAllocator), (VkPipeline*)(ret.data()));  }
inline void destroyPipeline(Device device, Pipeline pipeline = {}, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkDestroyPipeline, (VkDevice)(device), (VkPipeline)(pipeline), (const VkAllocationCallbacks*)(pAllocator)); }
inline PipelineLayout createPipelineLayout(Device device, const PipelineLayoutCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ PipelineLayout ret = {}; VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkCreatePipelineLayout, (VkDevice)(device), (const VkPipelineLayoutCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkPipelineLayout*)(&ret))); return ret; }
inline void destroyPipelineLayout(Device device, PipelineLayout pipelineLayout = {}, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkDestroyPipelineLayout, (VkDevice)(device), (VkPipelineLayout)(pipelineLayout), (const VkAllocationCallbacks*)(pAllocator)); }
inline Sampler createSampler(Device device, const SamplerCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ Sampler ret = {}; VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkCreateSampler, (VkDevice)(device), (const VkSamplerCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkSampler*)(&ret))); return ret; }
inline void destroySampler(Device device, Sampler sampler = {}, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkDestroySampler, (VkDevice)(device), (VkSampler)(sampler), (const VkAllocationCallbacks*)(pAllocator)); }
inline DescriptorSetLayout createDescriptorSetLayout(Device device, const DescriptorSetLayoutCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ DescriptorSetLayout ret = {}; VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkCreateDescriptorSetLayout, (VkDevice)(device), (const VkDescriptorSetLayoutCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkDescriptorSetLayout*)(&ret))); return ret; }
inline void destroyDescriptorSetLayout(Device device, DescriptorSetLayout descriptorSetLayout = {}, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkDestroyDescriptorSetLayout, (VkDevice)(device), (VkDescriptorSetLayout)(descriptorSetLayout), (const VkAllocationCallbacks*)(pAllocator)); }
inline DescriptorPool createDescriptorPool(Device device, const DescriptorPoolCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ DescriptorPool ret = {}; VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkCreateDescriptorPool, (VkDevice)(device), (const VkDescriptorPoolCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkDescriptorPool*)(&ret))); return ret; }
inline void destroyDescriptorPool(Device device, DescriptorPool descriptorPool = {}, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkDestroyDescriptorPool, (VkDevice)(device), (VkDescriptorPool)(descriptorPool), (const VkAllocationCallbacks*)(pAllocator)); }
inline Result resetDescriptorPool(Device device, DescriptorPool descriptorPool, DescriptorPoolResetFlags flags = {}, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkResetDescriptorPool, (VkDevice)(device), (VkDescriptorPool)(descriptorPool), static_cast<VkDescriptorPoolResetFlags>(flags)))); }
inline Result allocateDescriptorSets(Device device, const DescriptorSetAllocateInfo& pAllocateInfo, DescriptorSet& pDescriptorSets, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkAllocateDescriptorSets, (VkDevice)(device), (const VkDescriptorSetAllocateInfo*)(&pAllocateInfo), (VkDescriptorSet*)(&pDescriptorSets)))); }
inline std::vector<DescriptorSet> allocateDescriptorSets(Device device, const DescriptorSetAllocateInfo& pAllocateInfo, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC_RET(dispatcher, DescriptorSet, pAllocateInfo.descriptorSetCount, vkAllocateDescriptorSets, (VkDevice)(device), (const VkDescriptorSetAllocateInfo*)(&pAllocateInfo), (VkDescriptorSet*)(ret.data()));  }
inline Result freeDescriptorSets(Device device, DescriptorPool descriptorPool, uint32_t descriptorSetCount, const DescriptorSet& pDescriptorSets, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkFreeDescriptorSets, (VkDevice)(device), (VkDescriptorPool)(descriptorPool), descriptorSetCount, (const VkDescriptorSet*)(&pDescriptorSets)))); }
inline Result freeDescriptorSets(Device device, DescriptorPool descriptorPool, Span<const DescriptorSet> pDescriptorSets, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkFreeDescriptorSets, (VkDevice)(device), (VkDescriptorPool)(descriptorPool), pDescriptorSets.size(), (const VkDescriptorSet*)(pDescriptorSets.data())))); }
inline void updateDescriptorSets(Device device, uint32_t descriptorWriteCount, const WriteDescriptorSet& pDescriptorWrites, uint32_t descriptorCopyCount, const CopyDescriptorSet& pDescriptorCopies, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkUpdateDescriptorSets, (VkDevice)(device), descriptorWriteCount, (const VkWriteDescriptorSet*)(&pDescriptorWrites), descriptorCopyCount, (const VkCopyDescriptorSet*)(&pDescriptorCopies)); }
inline void updateDescriptorSets(Device device, Span<const WriteDescriptorSet> pDescriptorWrites, Span<const CopyDescriptorSet> pDescriptorCopies, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkUpdateDescriptorSets, (VkDevice)(device), pDescriptorWrites.size(), (const VkWriteDescriptorSet*)(pDescriptorWrites.data()), pDescriptorCopies.size(), (const VkCopyDescriptorSet*)(pDescriptorCopies.data())); }
inline Framebuffer createFramebuffer(Device device, const FramebufferCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ Framebuffer ret = {}; VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkCreateFramebuffer, (VkDevice)(device), (const VkFramebufferCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkFramebuffer*)(&ret))); return ret; }
inline void destroyFramebuffer(Device device, Framebuffer framebuffer = {}, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkDestroyFramebuffer, (VkDevice)(device), (VkFramebuffer)(framebuffer), (const VkAllocationCallbacks*)(pAllocator)); }
inline RenderPass createRenderPass(Device device, const RenderPassCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ RenderPass ret = {}; VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkCreateRenderPass, (VkDevice)(device), (const VkRenderPassCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkRenderPass*)(&ret))); return ret; }
inline void destroyRenderPass(Device device, RenderPass renderPass = {}, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkDestroyRenderPass, (VkDevice)(device), (VkRenderPass)(renderPass), (const VkAllocationCallbacks*)(pAllocator)); }
inline void getRenderAreaGranularity(Device device, RenderPass renderPass, Extent2D& pGranularity, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkGetRenderAreaGranularity, (VkDevice)(device), (VkRenderPass)(renderPass), (VkExtent2D*)(&pGranularity)); }
inline CommandPool createCommandPool(Device device, const CommandPoolCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ CommandPool ret = {}; VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkCreateCommandPool, (VkDevice)(device), (const VkCommandPoolCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkCommandPool*)(&ret))); return ret; }
inline void destroyCommandPool(Device device, CommandPool commandPool = {}, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkDestroyCommandPool, (VkDevice)(device), (VkCommandPool)(commandPool), (const VkAllocationCallbacks*)(pAllocator)); }
inline Result resetCommandPool(Device device, CommandPool commandPool, CommandPoolResetFlags flags = {}, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkResetCommandPool, (VkDevice)(device), (VkCommandPool)(commandPool), static_cast<VkCommandPoolResetFlags>(flags)))); }
inline Result allocateCommandBuffers(Device device, const CommandBufferAllocateInfo& pAllocateInfo, CommandBuffer& pCommandBuffers, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkAllocateCommandBuffers, (VkDevice)(device), (const VkCommandBufferAllocateInfo*)(&pAllocateInfo), (VkCommandBuffer*)(&pCommandBuffers)))); }
inline std::vector<CommandBuffer> allocateCommandBuffers(Device device, const CommandBufferAllocateInfo& pAllocateInfo, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC_RET(dispatcher, CommandBuffer, pAllocateInfo.commandBufferCount, vkAllocateCommandBuffers, (VkDevice)(device), (const VkCommandBufferAllocateInfo*)(&pAllocateInfo), (VkCommandBuffer*)(ret.data()));  }
inline void freeCommandBuffers(Device device, CommandPool commandPool, uint32_t commandBufferCount, const CommandBuffer& pCommandBuffers, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkFreeCommandBuffers, (VkDevice)(device), (VkCommandPool)(commandPool), commandBufferCount, (const VkCommandBuffer*)(&pCommandBuffers)); }
inline void freeCommandBuffers(Device device, CommandPool commandPool, Span<const CommandBuffer> pCommandBuffers, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkFreeCommandBuffers, (VkDevice)(device), (VkCommandPool)(commandPool), pCommandBuffers.size(), (const VkCommandBuffer*)(pCommandBuffers.data())); }
inline Result beginCommandBuffer(CommandBuffer commandBuffer, const CommandBufferBeginInfo& pBeginInfo, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkBeginCommandBuffer, (VkCommandBuffer)(commandBuffer), (const VkCommandBufferBeginInfo*)(&pBeginInfo)))); }
inline Result endCommandBuffer(CommandBuffer commandBuffer, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkEndCommandBuffer, (VkCommandBuffer)(commandBuffer)))); }
inline Result resetCommandBuffer(CommandBuffer commandBuffer, CommandBufferResetFlags flags = {}, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH(dispatcher, vkResetCommandBuffer, (VkCommandBuffer)(commandBuffer), static_cast<VkCommandBufferResetFlags>(flags)))); }
inline void cmdBindPipeline(CommandBuffer commandBuffer, PipelineBindPoint pipelineBindPoint, Pipeline pipeline, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdBindPipeline, (VkCommandBuffer)(commandBuffer), static_cast<VkPipelineBindPoint>(pipelineBindPoint), (VkPipeline)(pipeline)); }
inline void cmdSetViewport(CommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const Viewport& pViewports, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdSetViewport, (VkCommandBuffer)(commandBuffer), firstViewport, viewportCount, (const VkViewport*)(&pViewports)); }
inline void cmdSetViewport(CommandBuffer commandBuffer, uint32_t firstViewport, Span<const Viewport> pViewports, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdSetViewport, (VkCommandBuffer)(commandBuffer), firstViewport, pViewports.size(), (const VkViewport*)(pViewports.data())); }
inline void cmdSetScissor(CommandBuffer commandBuffer, uint32_t firstScissor, uint32_t scissorCount, const Rect2D& pScissors, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdSetScissor, (VkCommandBuffer)(commandBuffer), firstScissor, scissorCount, (const VkRect2D*)(&pScissors)); }
inline void cmdSetScissor(CommandBuffer commandBuffer, uint32_t firstScissor, Span<const Rect2D> pScissors, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdSetScissor, (VkCommandBuffer)(commandBuffer), firstScissor, pScissors.size(), (const VkRect2D*)(pScissors.data())); }
inline void cmdSetLineWidth(CommandBuffer commandBuffer, float lineWidth, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdSetLineWidth, (VkCommandBuffer)(commandBuffer), lineWidth); }
inline void cmdSetDepthBias(CommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdSetDepthBias, (VkCommandBuffer)(commandBuffer), depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor); }
inline void cmdSetBlendConstants(CommandBuffer commandBuffer, std::array<const float, 4> blendConstants, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdSetBlendConstants, (VkCommandBuffer)(commandBuffer), blendConstants.data()); }
inline void cmdSetDepthBounds(CommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdSetDepthBounds, (VkCommandBuffer)(commandBuffer), minDepthBounds, maxDepthBounds); }
inline void cmdSetStencilCompareMask(CommandBuffer commandBuffer, StencilFaceFlags faceMask, uint32_t compareMask, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdSetStencilCompareMask, (VkCommandBuffer)(commandBuffer), static_cast<VkStencilFaceFlags>(faceMask), compareMask); }
inline void cmdSetStencilWriteMask(CommandBuffer commandBuffer, StencilFaceFlags faceMask, uint32_t writeMask, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdSetStencilWriteMask, (VkCommandBuffer)(commandBuffer), static_cast<VkStencilFaceFlags>(faceMask), writeMask); }
inline void cmdSetStencilReference(CommandBuffer commandBuffer, StencilFaceFlags faceMask, uint32_t reference, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdSetStencilReference, (VkCommandBuffer)(commandBuffer), static_cast<VkStencilFaceFlags>(faceMask), reference); }
inline void cmdBindDescriptorSets(CommandBuffer commandBuffer, PipelineBindPoint pipelineBindPoint, PipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, const DescriptorSet& pDescriptorSets, uint32_t dynamicOffsetCount, const uint32_t& pDynamicOffsets, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdBindDescriptorSets, (VkCommandBuffer)(commandBuffer), static_cast<VkPipelineBindPoint>(pipelineBindPoint), (VkPipelineLayout)(layout), firstSet, descriptorSetCount, (const VkDescriptorSet*)(&pDescriptorSets), dynamicOffsetCount, (const uint32_t*)(&pDynamicOffsets)); }
inline void cmdBindDescriptorSets(CommandBuffer commandBuffer, PipelineBindPoint pipelineBindPoint, PipelineLayout layout, uint32_t firstSet, Span<const DescriptorSet> pDescriptorSets, Span<const uint32_t> pDynamicOffsets, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdBindDescriptorSets, (VkCommandBuffer)(commandBuffer), static_cast<VkPipelineBindPoint>(pipelineBindPoint), (VkPipelineLayout)(layout), firstSet, pDescriptorSets.size(), (const VkDescriptorSet*)(pDescriptorSets.data()), pDynamicOffsets.size(), (const uint32_t*)(pDynamicOffsets.data())); }
inline void cmdBindIndexBuffer(CommandBuffer commandBuffer, Buffer buffer, DeviceSize offset, IndexType indexType, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdBindIndexBuffer, (VkCommandBuffer)(commandBuffer), (VkBuffer)(buffer), offset, static_cast<VkIndexType>(indexType)); }
inline void cmdBindVertexBuffers(CommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const Buffer& pBuffers, const DeviceSize& pOffsets, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdBindVertexBuffers, (VkCommandBuffer)(commandBuffer), firstBinding, bindingCount, (const VkBuffer*)(&pBuffers), (const VkDeviceSize*)(&pOffsets)); }
inline void cmdBindVertexBuffers(CommandBuffer commandBuffer, uint32_t firstBinding, Span<const Buffer> pBuffers, Span<const DeviceSize> pOffsets, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdBindVertexBuffers, (VkCommandBuffer)(commandBuffer), firstBinding, pBuffers.size(), (const VkBuffer*)(pBuffers.data()), (const VkDeviceSize*)(pOffsets.data())); }
inline void cmdDraw(CommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdDraw, (VkCommandBuffer)(commandBuffer), vertexCount, instanceCount, firstVertex, firstInstance); }
inline void cmdDrawIndexed(CommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdDrawIndexed, (VkCommandBuffer)(commandBuffer), indexCount, instanceCount, firstIndex, vertexOffset, firstInstance); }
inline void cmdDrawIndirect(CommandBuffer commandBuffer, Buffer buffer, DeviceSize offset, uint32_t drawCount, uint32_t stride, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdDrawIndirect, (VkCommandBuffer)(commandBuffer), (VkBuffer)(buffer), offset, drawCount, stride); }
inline void cmdDrawIndexedIndirect(CommandBuffer commandBuffer, Buffer buffer, DeviceSize offset, uint32_t drawCount, uint32_t stride, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdDrawIndexedIndirect, (VkCommandBuffer)(commandBuffer), (VkBuffer)(buffer), offset, drawCount, stride); }
inline void cmdDispatch(CommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdDispatch, (VkCommandBuffer)(commandBuffer), groupCountX, groupCountY, groupCountZ); }
inline void cmdDispatchIndirect(CommandBuffer commandBuffer, Buffer buffer, DeviceSize offset, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdDispatchIndirect, (VkCommandBuffer)(commandBuffer), (VkBuffer)(buffer), offset); }
inline void cmdCopyBuffer(CommandBuffer commandBuffer, Buffer srcBuffer, Buffer dstBuffer, uint32_t regionCount, const BufferCopy& pRegions, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdCopyBuffer, (VkCommandBuffer)(commandBuffer), (VkBuffer)(srcBuffer), (VkBuffer)(dstBuffer), regionCount, (const VkBufferCopy*)(&pRegions)); }
inline void cmdCopyBuffer(CommandBuffer commandBuffer, Buffer srcBuffer, Buffer dstBuffer, Span<const BufferCopy> pRegions, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdCopyBuffer, (VkCommandBuffer)(commandBuffer), (VkBuffer)(srcBuffer), (VkBuffer)(dstBuffer), pRegions.size(), (const VkBufferCopy*)(pRegions.data())); }
inline void cmdCopyImage(CommandBuffer commandBuffer, Image srcImage, ImageLayout srcImageLayout, Image dstImage, ImageLayout dstImageLayout, uint32_t regionCount, const ImageCopy& pRegions, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdCopyImage, (VkCommandBuffer)(commandBuffer), (VkImage)(srcImage), static_cast<VkImageLayout>(srcImageLayout), (VkImage)(dstImage), static_cast<VkImageLayout>(dstImageLayout), regionCount, (const VkImageCopy*)(&pRegions)); }
inline void cmdCopyImage(CommandBuffer commandBuffer, Image srcImage, ImageLayout srcImageLayout, Image dstImage, ImageLayout dstImageLayout, Span<const ImageCopy> pRegions, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdCopyImage, (VkCommandBuffer)(commandBuffer), (VkImage)(srcImage), static_cast<VkImageLayout>(srcImageLayout), (VkImage)(dstImage), static_cast<VkImageLayout>(dstImageLayout), pRegions.size(), (const VkImageCopy*)(pRegions.data())); }
inline void cmdBlitImage(CommandBuffer commandBuffer, Image srcImage, ImageLayout srcImageLayout, Image dstImage, ImageLayout dstImageLayout, uint32_t regionCount, const ImageBlit& pRegions, Filter filter, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdBlitImage, (VkCommandBuffer)(commandBuffer), (VkImage)(srcImage), static_cast<VkImageLayout>(srcImageLayout), (VkImage)(dstImage), static_cast<VkImageLayout>(dstImageLayout), regionCount, (const VkImageBlit*)(&pRegions), static_cast<VkFilter>(filter)); }
inline void cmdBlitImage(CommandBuffer commandBuffer, Image srcImage, ImageLayout srcImageLayout, Image dstImage, ImageLayout dstImageLayout, Span<const ImageBlit> pRegions, Filter filter, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdBlitImage, (VkCommandBuffer)(commandBuffer), (VkImage)(srcImage), static_cast<VkImageLayout>(srcImageLayout), (VkImage)(dstImage), static_cast<VkImageLayout>(dstImageLayout), pRegions.size(), (const VkImageBlit*)(pRegions.data()), static_cast<VkFilter>(filter)); }
inline void cmdCopyBufferToImage(CommandBuffer commandBuffer, Buffer srcBuffer, Image dstImage, ImageLayout dstImageLayout, uint32_t regionCount, const BufferImageCopy& pRegions, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdCopyBufferToImage, (VkCommandBuffer)(commandBuffer), (VkBuffer)(srcBuffer), (VkImage)(dstImage), static_cast<VkImageLayout>(dstImageLayout), regionCount, (const VkBufferImageCopy*)(&pRegions)); }
inline void cmdCopyBufferToImage(CommandBuffer commandBuffer, Buffer srcBuffer, Image dstImage, ImageLayout dstImageLayout, Span<const BufferImageCopy> pRegions, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdCopyBufferToImage, (VkCommandBuffer)(commandBuffer), (VkBuffer)(srcBuffer), (VkImage)(dstImage), static_cast<VkImageLayout>(dstImageLayout), pRegions.size(), (const VkBufferImageCopy*)(pRegions.data())); }
inline void cmdCopyImageToBuffer(CommandBuffer commandBuffer, Image srcImage, ImageLayout srcImageLayout, Buffer dstBuffer, uint32_t regionCount, const BufferImageCopy& pRegions, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdCopyImageToBuffer, (VkCommandBuffer)(commandBuffer), (VkImage)(srcImage), static_cast<VkImageLayout>(srcImageLayout), (VkBuffer)(dstBuffer), regionCount, (const VkBufferImageCopy*)(&pRegions)); }
inline void cmdCopyImageToBuffer(CommandBuffer commandBuffer, Image srcImage, ImageLayout srcImageLayout, Buffer dstBuffer, Span<const BufferImageCopy> pRegions, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdCopyImageToBuffer, (VkCommandBuffer)(commandBuffer), (VkImage)(srcImage), static_cast<VkImageLayout>(srcImageLayout), (VkBuffer)(dstBuffer), pRegions.size(), (const VkBufferImageCopy*)(pRegions.data())); }
inline void cmdUpdateBuffer(CommandBuffer commandBuffer, Buffer dstBuffer, DeviceSize dstOffset, DeviceSize dataSize, const void* pData, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdUpdateBuffer, (VkCommandBuffer)(commandBuffer), (VkBuffer)(dstBuffer), dstOffset, dataSize, (const void*)(pData)); }
inline void cmdUpdateBuffer(CommandBuffer commandBuffer, Buffer dstBuffer, DeviceSize dstOffset, Span<const uint8_t> pData, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdUpdateBuffer, (VkCommandBuffer)(commandBuffer), (VkBuffer)(dstBuffer), dstOffset, pData.size(), (const void*)(pData.data())); }
inline void cmdFillBuffer(CommandBuffer commandBuffer, Buffer dstBuffer, DeviceSize dstOffset, DeviceSize size, uint32_t data, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdFillBuffer, (VkCommandBuffer)(commandBuffer), (VkBuffer)(dstBuffer), dstOffset, size, data); }
inline void cmdClearColorImage(CommandBuffer commandBuffer, Image image, ImageLayout imageLayout, const ClearColorValue& pColor, uint32_t rangeCount, const ImageSubresourceRange& pRanges, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdClearColorImage, (VkCommandBuffer)(commandBuffer), (VkImage)(image), static_cast<VkImageLayout>(imageLayout), (const VkClearColorValue*)(&pColor), rangeCount, (const VkImageSubresourceRange*)(&pRanges)); }
inline void cmdClearColorImage(CommandBuffer commandBuffer, Image image, ImageLayout imageLayout, const ClearColorValue& pColor, Span<const ImageSubresourceRange> pRanges, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdClearColorImage, (VkCommandBuffer)(commandBuffer), (VkImage)(image), static_cast<VkImageLayout>(imageLayout), (const VkClearColorValue*)(&pColor), pRanges.size(), (const VkImageSubresourceRange*)(pRanges.data())); }
inline void cmdClearDepthStencilImage(CommandBuffer commandBuffer, Image image, ImageLayout imageLayout, const ClearDepthStencilValue& pDepthStencil, uint32_t rangeCount, const ImageSubresourceRange& pRanges, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdClearDepthStencilImage, (VkCommandBuffer)(commandBuffer), (VkImage)(image), static_cast<VkImageLayout>(imageLayout), (const VkClearDepthStencilValue*)(&pDepthStencil), rangeCount, (const VkImageSubresourceRange*)(&pRanges)); }
inline void cmdClearDepthStencilImage(CommandBuffer commandBuffer, Image image, ImageLayout imageLayout, const ClearDepthStencilValue& pDepthStencil, Span<const ImageSubresourceRange> pRanges, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdClearDepthStencilImage, (VkCommandBuffer)(commandBuffer), (VkImage)(image), static_cast<VkImageLayout>(imageLayout), (const VkClearDepthStencilValue*)(&pDepthStencil), pRanges.size(), (const VkImageSubresourceRange*)(pRanges.data())); }
inline void cmdClearAttachments(CommandBuffer commandBuffer, uint32_t attachmentCount, const ClearAttachment& pAttachments, uint32_t rectCount, const ClearRect& pRects, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdClearAttachments, (VkCommandBuffer)(commandBuffer), attachmentCount, (const VkClearAttachment*)(&pAttachments), rectCount, (const VkClearRect*)(&pRects)); }
inline void cmdClearAttachments(CommandBuffer commandBuffer, Span<const ClearAttachment> pAttachments, Span<const ClearRect> pRects, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdClearAttachments, (VkCommandBuffer)(commandBuffer), pAttachments.size(), (const VkClearAttachment*)(pAttachments.data()), pRects.size(), (const VkClearRect*)(pRects.data())); }
inline void cmdResolveImage(CommandBuffer commandBuffer, Image srcImage, ImageLayout srcImageLayout, Image dstImage, ImageLayout dstImageLayout, uint32_t regionCount, const ImageResolve& pRegions, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdResolveImage, (VkCommandBuffer)(commandBuffer), (VkImage)(srcImage), static_cast<VkImageLayout>(srcImageLayout), (VkImage)(dstImage), static_cast<VkImageLayout>(dstImageLayout), regionCount, (const VkImageResolve*)(&pRegions)); }
inline void cmdResolveImage(CommandBuffer commandBuffer, Image srcImage, ImageLayout srcImageLayout, Image dstImage, ImageLayout dstImageLayout, Span<const ImageResolve> pRegions, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdResolveImage, (VkCommandBuffer)(commandBuffer), (VkImage)(srcImage), static_cast<VkImageLayout>(srcImageLayout), (VkImage)(dstImage), static_cast<VkImageLayout>(dstImageLayout), pRegions.size(), (const VkImageResolve*)(pRegions.data())); }
inline void cmdSetEvent(CommandBuffer commandBuffer, Event event, PipelineStageFlags stageMask, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdSetEvent, (VkCommandBuffer)(commandBuffer), (VkEvent)(event), static_cast<VkPipelineStageFlags>(stageMask)); }
inline void cmdResetEvent(CommandBuffer commandBuffer, Event event, PipelineStageFlags stageMask, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdResetEvent, (VkCommandBuffer)(commandBuffer), (VkEvent)(event), static_cast<VkPipelineStageFlags>(stageMask)); }
inline void cmdWaitEvents(CommandBuffer commandBuffer, uint32_t eventCount, const Event& pEvents, PipelineStageFlags srcStageMask, PipelineStageFlags dstStageMask, uint32_t memoryBarrierCount, const MemoryBarrier& pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const BufferMemoryBarrier& pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const ImageMemoryBarrier& pImageMemoryBarriers, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdWaitEvents, (VkCommandBuffer)(commandBuffer), eventCount, (const VkEvent*)(&pEvents), static_cast<VkPipelineStageFlags>(srcStageMask), static_cast<VkPipelineStageFlags>(dstStageMask), memoryBarrierCount, (const VkMemoryBarrier*)(&pMemoryBarriers), bufferMemoryBarrierCount, (const VkBufferMemoryBarrier*)(&pBufferMemoryBarriers), imageMemoryBarrierCount, (const VkImageMemoryBarrier*)(&pImageMemoryBarriers)); }
inline void cmdWaitEvents(CommandBuffer commandBuffer, Span<const Event> pEvents, PipelineStageFlags srcStageMask, PipelineStageFlags dstStageMask, Span<const MemoryBarrier> pMemoryBarriers, Span<const BufferMemoryBarrier> pBufferMemoryBarriers, Span<const ImageMemoryBarrier> pImageMemoryBarriers, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdWaitEvents, (VkCommandBuffer)(commandBuffer), pEvents.size(), (const VkEvent*)(pEvents.data()), static_cast<VkPipelineStageFlags>(srcStageMask), static_cast<VkPipelineStageFlags>(dstStageMask), pMemoryBarriers.size(), (const VkMemoryBarrier*)(pMemoryBarriers.data()), pBufferMemoryBarriers.size(), (const VkBufferMemoryBarrier*)(pBufferMemoryBarriers.data()), pImageMemoryBarriers.size(), (const VkImageMemoryBarrier*)(pImageMemoryBarriers.data())); }
inline void cmdPipelineBarrier(CommandBuffer commandBuffer, PipelineStageFlags srcStageMask, PipelineStageFlags dstStageMask, DependencyFlags dependencyFlags, uint32_t memoryBarrierCount, const MemoryBarrier& pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const BufferMemoryBarrier& pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const ImageMemoryBarrier& pImageMemoryBarriers, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdPipelineBarrier, (VkCommandBuffer)(commandBuffer), static_cast<VkPipelineStageFlags>(srcStageMask), static_cast<VkPipelineStageFlags>(dstStageMask), static_cast<VkDependencyFlags>(dependencyFlags), memoryBarrierCount, (const VkMemoryBarrier*)(&pMemoryBarriers), bufferMemoryBarrierCount, (const VkBufferMemoryBarrier*)(&pBufferMemoryBarriers), imageMemoryBarrierCount, (const VkImageMemoryBarrier*)(&pImageMemoryBarriers)); }
inline void cmdPipelineBarrier(CommandBuffer commandBuffer, PipelineStageFlags srcStageMask, PipelineStageFlags dstStageMask, DependencyFlags dependencyFlags, Span<const MemoryBarrier> pMemoryBarriers, Span<const BufferMemoryBarrier> pBufferMemoryBarriers, Span<const ImageMemoryBarrier> pImageMemoryBarriers, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdPipelineBarrier, (VkCommandBuffer)(commandBuffer), static_cast<VkPipelineStageFlags>(srcStageMask), static_cast<VkPipelineStageFlags>(dstStageMask), static_cast<VkDependencyFlags>(dependencyFlags), pMemoryBarriers.size(), (const VkMemoryBarrier*)(pMemoryBarriers.data()), pBufferMemoryBarriers.size(), (const VkBufferMemoryBarrier*)(pBufferMemoryBarriers.data()), pImageMemoryBarriers.size(), (const VkImageMemoryBarrier*)(pImageMemoryBarriers.data())); }
inline void cmdBeginQuery(CommandBuffer commandBuffer, QueryPool queryPool, uint32_t query, QueryControlFlags flags = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdBeginQuery, (VkCommandBuffer)(commandBuffer), (VkQueryPool)(queryPool), query, static_cast<VkQueryControlFlags>(flags)); }
inline void cmdEndQuery(CommandBuffer commandBuffer, QueryPool queryPool, uint32_t query, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdEndQuery, (VkCommandBuffer)(commandBuffer), (VkQueryPool)(queryPool), query); }
inline void cmdResetQueryPool(CommandBuffer commandBuffer, QueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdResetQueryPool, (VkCommandBuffer)(commandBuffer), (VkQueryPool)(queryPool), firstQuery, queryCount); }
inline void cmdWriteTimestamp(CommandBuffer commandBuffer, PipelineStageBits pipelineStage, QueryPool queryPool, uint32_t query, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdWriteTimestamp, (VkCommandBuffer)(commandBuffer), static_cast<VkPipelineStageFlagBits>(pipelineStage), (VkQueryPool)(queryPool), query); }
inline void cmdCopyQueryPoolResults(CommandBuffer commandBuffer, QueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, Buffer dstBuffer, DeviceSize dstOffset, DeviceSize stride, QueryResultFlags flags = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdCopyQueryPoolResults, (VkCommandBuffer)(commandBuffer), (VkQueryPool)(queryPool), firstQuery, queryCount, (VkBuffer)(dstBuffer), dstOffset, stride, static_cast<VkQueryResultFlags>(flags)); }
inline void cmdPushConstants(CommandBuffer commandBuffer, PipelineLayout layout, ShaderStageFlags stageFlags, uint32_t offset, uint32_t size, const void* pValues, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdPushConstants, (VkCommandBuffer)(commandBuffer), (VkPipelineLayout)(layout), static_cast<VkShaderStageFlags>(stageFlags), offset, size, (const void*)(pValues)); }
inline void cmdPushConstants(CommandBuffer commandBuffer, PipelineLayout layout, ShaderStageFlags stageFlags, uint32_t offset, Span<const uint8_t> pValues, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdPushConstants, (VkCommandBuffer)(commandBuffer), (VkPipelineLayout)(layout), static_cast<VkShaderStageFlags>(stageFlags), offset, pValues.size(), (const void*)(pValues.data())); }
inline void cmdBeginRenderPass(CommandBuffer commandBuffer, const RenderPassBeginInfo& pRenderPassBegin, SubpassContents contents, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdBeginRenderPass, (VkCommandBuffer)(commandBuffer), (const VkRenderPassBeginInfo*)(&pRenderPassBegin), static_cast<VkSubpassContents>(contents)); }
inline void cmdNextSubpass(CommandBuffer commandBuffer, SubpassContents contents, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdNextSubpass, (VkCommandBuffer)(commandBuffer), static_cast<VkSubpassContents>(contents)); }
inline void cmdEndRenderPass(CommandBuffer commandBuffer, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdEndRenderPass, (VkCommandBuffer)(commandBuffer)); }
inline void cmdExecuteCommands(CommandBuffer commandBuffer, uint32_t commandBufferCount, const CommandBuffer& pCommandBuffers, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdExecuteCommands, (VkCommandBuffer)(commandBuffer), commandBufferCount, (const VkCommandBuffer*)(&pCommandBuffers)); }
inline void cmdExecuteCommands(CommandBuffer commandBuffer, Span<const CommandBuffer> pCommandBuffers, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH(dispatcher, vkCmdExecuteCommands, (VkCommandBuffer)(commandBuffer), pCommandBuffers.size(), (const VkCommandBuffer*)(pCommandBuffers.data())); }

inline void destroySurfaceKHR(Instance instance, SurfaceKHR surface = {}, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkDestroySurfaceKHR, (VkInstance)(instance), (VkSurfaceKHR)(surface), (const VkAllocationCallbacks*)(pAllocator)); }
inline Bool32 getPhysicalDeviceSurfaceSupportKHR(PhysicalDevice physicalDevice, uint32_t queueFamilyIndex, SurfaceKHR surface, DynamicDispatch* dispatcher = nullptr){ Bool32 ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPhysicalDeviceSurfaceSupportKHR, (VkPhysicalDevice)(physicalDevice), queueFamilyIndex, (VkSurfaceKHR)(surface), (VkBool32*)(&ret))); return ret; }
inline SurfaceCapabilitiesKHR getPhysicalDeviceSurfaceCapabilitiesKHR(PhysicalDevice physicalDevice, SurfaceKHR surface, DynamicDispatch* dispatcher = nullptr){ SurfaceCapabilitiesKHR ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPhysicalDeviceSurfaceCapabilitiesKHR, (VkPhysicalDevice)(physicalDevice), (VkSurfaceKHR)(surface), (VkSurfaceCapabilitiesKHR*)(&ret))); return ret; }
inline Result getPhysicalDeviceSurfaceFormatsKHR(PhysicalDevice physicalDevice, SurfaceKHR surface, uint32_t& pSurfaceFormatCount, SurfaceFormatKHR* pSurfaceFormats = {}, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPhysicalDeviceSurfaceFormatsKHR, (VkPhysicalDevice)(physicalDevice), (VkSurfaceKHR)(surface), (uint32_t*)(&pSurfaceFormatCount), (VkSurfaceFormatKHR*)(pSurfaceFormats)))); }
inline std::vector<SurfaceFormatKHR> getPhysicalDeviceSurfaceFormatsKHR(PhysicalDevice physicalDevice, SurfaceKHR surface, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC_G(dispatcher, SurfaceFormatKHR, uint32_t, vkGetPhysicalDeviceSurfaceFormatsKHR, (VkPhysicalDevice)(physicalDevice), (VkSurfaceKHR)(surface), &count, (VkSurfaceFormatKHR*)(ret.data()));  }
inline Result getPhysicalDeviceSurfacePresentModesKHR(PhysicalDevice physicalDevice, SurfaceKHR surface, uint32_t& pPresentModeCount, PresentModeKHR* pPresentModes = {}, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPhysicalDeviceSurfacePresentModesKHR, (VkPhysicalDevice)(physicalDevice), (VkSurfaceKHR)(surface), (uint32_t*)(&pPresentModeCount), (VkPresentModeKHR*)(pPresentModes)))); }
inline std::vector<PresentModeKHR> getPhysicalDeviceSurfacePresentModesKHR(PhysicalDevice physicalDevice, SurfaceKHR surface, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC_G(dispatcher, PresentModeKHR, uint32_t, vkGetPhysicalDeviceSurfacePresentModesKHR, (VkPhysicalDevice)(physicalDevice), (VkSurfaceKHR)(surface), &count, (VkPresentModeKHR*)(ret.data()));  }

inline SwapchainKHR createSwapchainKHR(Device device, const SwapchainCreateInfoKHR& pCreateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ SwapchainKHR ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkCreateSwapchainKHR, (VkDevice)(device), (const VkSwapchainCreateInfoKHR*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkSwapchainKHR*)(&ret))); return ret; }
inline void destroySwapchainKHR(Device device, SwapchainKHR swapchain = {}, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkDestroySwapchainKHR, (VkDevice)(device), (VkSwapchainKHR)(swapchain), (const VkAllocationCallbacks*)(pAllocator)); }
inline Result getSwapchainImagesKHR(Device device, SwapchainKHR swapchain, uint32_t& pSwapchainImageCount, Image* pSwapchainImages = {}, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetSwapchainImagesKHR, (VkDevice)(device), (VkSwapchainKHR)(swapchain), (uint32_t*)(&pSwapchainImageCount), (VkImage*)(pSwapchainImages)))); }
inline std::vector<Image> getSwapchainImagesKHR(Device device, SwapchainKHR swapchain, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC_G(dispatcher, Image, uint32_t, vkGetSwapchainImagesKHR, (VkDevice)(device), (VkSwapchainKHR)(swapchain), &count, (VkImage*)(ret.data()));  }
inline uint32_t acquireNextImageKHR(Device device, SwapchainKHR swapchain, uint64_t timeout, Semaphore semaphore = {}, Fence fence = {}, DynamicDispatch* dispatcher = nullptr){ uint32_t ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkAcquireNextImageKHR, (VkDevice)(device), (VkSwapchainKHR)(swapchain), timeout, (VkSemaphore)(semaphore), (VkFence)(fence), (uint32_t*)(&ret))); return ret; }
inline Result queuePresentKHR(Queue queue, const PresentInfoKHR& pPresentInfo, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkQueuePresentKHR, (VkQueue)(queue), (const VkPresentInfoKHR*)(&pPresentInfo)))); }
inline DeviceGroupPresentCapabilitiesKHR getDeviceGroupPresentCapabilitiesKHR(Device device, DynamicDispatch* dispatcher = nullptr){ DeviceGroupPresentCapabilitiesKHR ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetDeviceGroupPresentCapabilitiesKHR, (VkDevice)(device), (VkDeviceGroupPresentCapabilitiesKHR*)(&ret))); return ret; }
inline DeviceGroupPresentModeFlagsKHR getDeviceGroupSurfacePresentModesKHR(Device device, SurfaceKHR surface, DynamicDispatch* dispatcher = nullptr){ DeviceGroupPresentModeFlagsKHR ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetDeviceGroupSurfacePresentModesKHR, (VkDevice)(device), (VkSurfaceKHR)(surface), (VkDeviceGroupPresentModeFlagsKHR*)(&ret))); return ret; }
inline Result getPhysicalDevicePresentRectanglesKHR(PhysicalDevice physicalDevice, SurfaceKHR surface, uint32_t& pRectCount, Rect2D* pRects = {}, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPhysicalDevicePresentRectanglesKHR, (VkPhysicalDevice)(physicalDevice), (VkSurfaceKHR)(surface), (uint32_t*)(&pRectCount), (VkRect2D*)(pRects)))); }
inline std::vector<Rect2D> getPhysicalDevicePresentRectanglesKHR(PhysicalDevice physicalDevice, SurfaceKHR surface, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC_G(dispatcher, Rect2D, uint32_t, vkGetPhysicalDevicePresentRectanglesKHR, (VkPhysicalDevice)(physicalDevice), (VkSurfaceKHR)(surface), &count, (VkRect2D*)(ret.data()));  }
inline uint32_t acquireNextImage2KHR(Device device, const AcquireNextImageInfoKHR& pAcquireInfo, DynamicDispatch* dispatcher = nullptr){ uint32_t ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkAcquireNextImage2KHR, (VkDevice)(device), (const VkAcquireNextImageInfoKHR*)(&pAcquireInfo), (uint32_t*)(&ret))); return ret; }

inline Result getPhysicalDeviceDisplayPropertiesKHR(PhysicalDevice physicalDevice, uint32_t& pPropertyCount, DisplayPropertiesKHR* pProperties = {}, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPhysicalDeviceDisplayPropertiesKHR, (VkPhysicalDevice)(physicalDevice), (uint32_t*)(&pPropertyCount), (VkDisplayPropertiesKHR*)(pProperties)))); }
inline std::vector<DisplayPropertiesKHR> getPhysicalDeviceDisplayPropertiesKHR(PhysicalDevice physicalDevice, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC_G(dispatcher, DisplayPropertiesKHR, uint32_t, vkGetPhysicalDeviceDisplayPropertiesKHR, (VkPhysicalDevice)(physicalDevice), &count, (VkDisplayPropertiesKHR*)(ret.data()));  }
inline Result getPhysicalDeviceDisplayPlanePropertiesKHR(PhysicalDevice physicalDevice, uint32_t& pPropertyCount, DisplayPlanePropertiesKHR* pProperties = {}, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPhysicalDeviceDisplayPlanePropertiesKHR, (VkPhysicalDevice)(physicalDevice), (uint32_t*)(&pPropertyCount), (VkDisplayPlanePropertiesKHR*)(pProperties)))); }
inline std::vector<DisplayPlanePropertiesKHR> getPhysicalDeviceDisplayPlanePropertiesKHR(PhysicalDevice physicalDevice, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC_G(dispatcher, DisplayPlanePropertiesKHR, uint32_t, vkGetPhysicalDeviceDisplayPlanePropertiesKHR, (VkPhysicalDevice)(physicalDevice), &count, (VkDisplayPlanePropertiesKHR*)(ret.data()));  }
inline Result getDisplayPlaneSupportedDisplaysKHR(PhysicalDevice physicalDevice, uint32_t planeIndex, uint32_t& pDisplayCount, DisplayKHR* pDisplays = {}, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetDisplayPlaneSupportedDisplaysKHR, (VkPhysicalDevice)(physicalDevice), planeIndex, (uint32_t*)(&pDisplayCount), (VkDisplayKHR*)(pDisplays)))); }
inline std::vector<DisplayKHR> getDisplayPlaneSupportedDisplaysKHR(PhysicalDevice physicalDevice, uint32_t planeIndex, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC_G(dispatcher, DisplayKHR, uint32_t, vkGetDisplayPlaneSupportedDisplaysKHR, (VkPhysicalDevice)(physicalDevice), planeIndex, &count, (VkDisplayKHR*)(ret.data()));  }
inline Result getDisplayModePropertiesKHR(PhysicalDevice physicalDevice, DisplayKHR display, uint32_t& pPropertyCount, DisplayModePropertiesKHR* pProperties = {}, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetDisplayModePropertiesKHR, (VkPhysicalDevice)(physicalDevice), (VkDisplayKHR)(display), (uint32_t*)(&pPropertyCount), (VkDisplayModePropertiesKHR*)(pProperties)))); }
inline std::vector<DisplayModePropertiesKHR> getDisplayModePropertiesKHR(PhysicalDevice physicalDevice, DisplayKHR display, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC_G(dispatcher, DisplayModePropertiesKHR, uint32_t, vkGetDisplayModePropertiesKHR, (VkPhysicalDevice)(physicalDevice), (VkDisplayKHR)(display), &count, (VkDisplayModePropertiesKHR*)(ret.data()));  }
inline DisplayModeKHR createDisplayModeKHR(PhysicalDevice physicalDevice, DisplayKHR display, const DisplayModeCreateInfoKHR& pCreateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ DisplayModeKHR ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkCreateDisplayModeKHR, (VkPhysicalDevice)(physicalDevice), (VkDisplayKHR)(display), (const VkDisplayModeCreateInfoKHR*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkDisplayModeKHR*)(&ret))); return ret; }
inline DisplayPlaneCapabilitiesKHR getDisplayPlaneCapabilitiesKHR(PhysicalDevice physicalDevice, DisplayModeKHR mode, uint32_t planeIndex, DynamicDispatch* dispatcher = nullptr){ DisplayPlaneCapabilitiesKHR ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetDisplayPlaneCapabilitiesKHR, (VkPhysicalDevice)(physicalDevice), (VkDisplayModeKHR)(mode), planeIndex, (VkDisplayPlaneCapabilitiesKHR*)(&ret))); return ret; }
inline SurfaceKHR createDisplayPlaneSurfaceKHR(Instance instance, const DisplaySurfaceCreateInfoKHR& pCreateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ SurfaceKHR ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkCreateDisplayPlaneSurfaceKHR, (VkInstance)(instance), (const VkDisplaySurfaceCreateInfoKHR*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkSurfaceKHR*)(&ret))); return ret; }

inline Result createSharedSwapchainsKHR(Device device, uint32_t swapchainCount, const SwapchainCreateInfoKHR& pCreateInfos, const AllocationCallbacks* pAllocator, SwapchainKHR& pSwapchains, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkCreateSharedSwapchainsKHR, (VkDevice)(device), swapchainCount, (const VkSwapchainCreateInfoKHR*)(&pCreateInfos), (const VkAllocationCallbacks*)(pAllocator), (VkSwapchainKHR*)(&pSwapchains)))); }
inline std::vector<SwapchainKHR> createSharedSwapchainsKHR(Device device, Span<const SwapchainCreateInfoKHR> pCreateInfos, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC_RET_G(dispatcher, SwapchainKHR, pCreateInfos.size(), vkCreateSharedSwapchainsKHR, (VkDevice)(device), pCreateInfos.size(), (const VkSwapchainCreateInfoKHR*)(pCreateInfos.data()), (const VkAllocationCallbacks*)(pAllocator), (VkSwapchainKHR*)(ret.data()));  }

#ifdef VK_USE_PLATFORM_XLIB_KHR

inline SurfaceKHR createXlibSurfaceKHR(Instance instance, const XlibSurfaceCreateInfoKHR& pCreateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ SurfaceKHR ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkCreateXlibSurfaceKHR, (VkInstance)(instance), (const VkXlibSurfaceCreateInfoKHR*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkSurfaceKHR*)(&ret))); return ret; }
inline Display getPhysicalDeviceXlibPresentationSupportKHR(PhysicalDevice physicalDevice, uint32_t queueFamilyIndex, VisualID visualID, DynamicDispatch* dispatcher = nullptr){ Display ret = {}; VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPhysicalDeviceXlibPresentationSupportKHR, (VkPhysicalDevice)(physicalDevice), queueFamilyIndex, (Display*)(&ret), visualID); return ret; }

#endif //VK_USE_PLATFORM_XLIB_KHR

#ifdef VK_USE_PLATFORM_XCB_KHR

inline SurfaceKHR createXcbSurfaceKHR(Instance instance, const XcbSurfaceCreateInfoKHR& pCreateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ SurfaceKHR ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkCreateXcbSurfaceKHR, (VkInstance)(instance), (const VkXcbSurfaceCreateInfoKHR*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkSurfaceKHR*)(&ret))); return ret; }
inline xcb_connection_t getPhysicalDeviceXcbPresentationSupportKHR(PhysicalDevice physicalDevice, uint32_t queueFamilyIndex, xcb_visualid_t visual_id, DynamicDispatch* dispatcher = nullptr){ xcb_connection_t ret = {}; VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPhysicalDeviceXcbPresentationSupportKHR, (VkPhysicalDevice)(physicalDevice), queueFamilyIndex, (xcb_connection_t*)(&ret), visual_id); return ret; }

#endif //VK_USE_PLATFORM_XCB_KHR

#ifdef VK_USE_PLATFORM_WAYLAND_KHR

inline SurfaceKHR createWaylandSurfaceKHR(Instance instance, const WaylandSurfaceCreateInfoKHR& pCreateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ SurfaceKHR ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkCreateWaylandSurfaceKHR, (VkInstance)(instance), (const VkWaylandSurfaceCreateInfoKHR*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkSurfaceKHR*)(&ret))); return ret; }
inline wl_display getPhysicalDeviceWaylandPresentationSupportKHR(PhysicalDevice physicalDevice, uint32_t queueFamilyIndex, DynamicDispatch* dispatcher = nullptr){ wl_display ret = {}; VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPhysicalDeviceWaylandPresentationSupportKHR, (VkPhysicalDevice)(physicalDevice), queueFamilyIndex, (wl_display*)(&ret)); return ret; }

#endif //VK_USE_PLATFORM_WAYLAND_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR

inline SurfaceKHR createWin32SurfaceKHR(Instance instance, const Win32SurfaceCreateInfoKHR& pCreateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ SurfaceKHR ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkCreateWin32SurfaceKHR, (VkInstance)(instance), (const VkWin32SurfaceCreateInfoKHR*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkSurfaceKHR*)(&ret))); return ret; }
inline Bool32 getPhysicalDeviceWin32PresentationSupportKHR(PhysicalDevice physicalDevice, uint32_t queueFamilyIndex, DynamicDispatch* dispatcher = nullptr){ return static_cast<Bool32>(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPhysicalDeviceWin32PresentationSupportKHR, (VkPhysicalDevice)(physicalDevice), queueFamilyIndex)); }

#endif //VK_USE_PLATFORM_WIN32_KHR

inline DebugReportCallbackEXT createDebugReportCallbackEXT(Instance instance, const DebugReportCallbackCreateInfoEXT& pCreateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ DebugReportCallbackEXT ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkCreateDebugReportCallbackEXT, (VkInstance)(instance), (const VkDebugReportCallbackCreateInfoEXT*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkDebugReportCallbackEXT*)(&ret))); return ret; }
inline void destroyDebugReportCallbackEXT(Instance instance, DebugReportCallbackEXT callback, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkDestroyDebugReportCallbackEXT, (VkInstance)(instance), (VkDebugReportCallbackEXT)(callback), (const VkAllocationCallbacks*)(pAllocator)); }
inline void debugReportMessageEXT(Instance instance, DebugReportFlagsEXT flags, DebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char* pLayerPrefix, const char* pMessage, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkDebugReportMessageEXT, (VkInstance)(instance), static_cast<VkDebugReportFlagsEXT>(flags), static_cast<VkDebugReportObjectTypeEXT>(objectType), object, location, messageCode, (const char*)(pLayerPrefix), (const char*)(pMessage)); }

inline Result debugMarkerSetObjectTagEXT(Device device, const DebugMarkerObjectTagInfoEXT& pTagInfo, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkDebugMarkerSetObjectTagEXT, (VkDevice)(device), (const VkDebugMarkerObjectTagInfoEXT*)(&pTagInfo)))); }
inline Result debugMarkerSetObjectNameEXT(Device device, const DebugMarkerObjectNameInfoEXT& pNameInfo, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkDebugMarkerSetObjectNameEXT, (VkDevice)(device), (const VkDebugMarkerObjectNameInfoEXT*)(&pNameInfo)))); }
inline void cmdDebugMarkerBeginEXT(CommandBuffer commandBuffer, const DebugMarkerMarkerInfoEXT& pMarkerInfo, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdDebugMarkerBeginEXT, (VkCommandBuffer)(commandBuffer), (const VkDebugMarkerMarkerInfoEXT*)(&pMarkerInfo)); }
inline void cmdDebugMarkerEndEXT(CommandBuffer commandBuffer, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdDebugMarkerEndEXT, (VkCommandBuffer)(commandBuffer)); }
inline void cmdDebugMarkerInsertEXT(CommandBuffer commandBuffer, const DebugMarkerMarkerInfoEXT& pMarkerInfo, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdDebugMarkerInsertEXT, (VkCommandBuffer)(commandBuffer), (const VkDebugMarkerMarkerInfoEXT*)(&pMarkerInfo)); }

inline void cmdBindTransformFeedbackBuffersEXT(CommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const Buffer& pBuffers, const DeviceSize& pOffsets, const DeviceSize* pSizes = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdBindTransformFeedbackBuffersEXT, (VkCommandBuffer)(commandBuffer), firstBinding, bindingCount, (const VkBuffer*)(&pBuffers), (const VkDeviceSize*)(&pOffsets), (const VkDeviceSize*)(pSizes)); }
inline void cmdBindTransformFeedbackBuffersEXT(CommandBuffer commandBuffer, uint32_t firstBinding, Span<const Buffer> pBuffers, Span<const DeviceSize> pOffsets, Span<const DeviceSize> pSizes, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdBindTransformFeedbackBuffersEXT, (VkCommandBuffer)(commandBuffer), firstBinding, pBuffers.size(), (const VkBuffer*)(pBuffers.data()), (const VkDeviceSize*)(pOffsets.data()), (const VkDeviceSize*)(pSizes.data())); }
inline void cmdBeginTransformFeedbackEXT(CommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const Buffer& pCounterBuffers, const DeviceSize* pCounterBufferOffsets = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdBeginTransformFeedbackEXT, (VkCommandBuffer)(commandBuffer), firstCounterBuffer, counterBufferCount, (const VkBuffer*)(&pCounterBuffers), (const VkDeviceSize*)(pCounterBufferOffsets)); }
inline void cmdBeginTransformFeedbackEXT(CommandBuffer commandBuffer, uint32_t firstCounterBuffer, Span<const Buffer> pCounterBuffers, Span<const DeviceSize> pCounterBufferOffsets, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdBeginTransformFeedbackEXT, (VkCommandBuffer)(commandBuffer), firstCounterBuffer, pCounterBuffers.size(), (const VkBuffer*)(pCounterBuffers.data()), (const VkDeviceSize*)(pCounterBufferOffsets.data())); }
inline void cmdEndTransformFeedbackEXT(CommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const Buffer& pCounterBuffers, const DeviceSize* pCounterBufferOffsets = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdEndTransformFeedbackEXT, (VkCommandBuffer)(commandBuffer), firstCounterBuffer, counterBufferCount, (const VkBuffer*)(&pCounterBuffers), (const VkDeviceSize*)(pCounterBufferOffsets)); }
inline void cmdEndTransformFeedbackEXT(CommandBuffer commandBuffer, uint32_t firstCounterBuffer, Span<const Buffer> pCounterBuffers, Span<const DeviceSize> pCounterBufferOffsets, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdEndTransformFeedbackEXT, (VkCommandBuffer)(commandBuffer), firstCounterBuffer, pCounterBuffers.size(), (const VkBuffer*)(pCounterBuffers.data()), (const VkDeviceSize*)(pCounterBufferOffsets.data())); }
inline void cmdBeginQueryIndexedEXT(CommandBuffer commandBuffer, QueryPool queryPool, uint32_t query, QueryControlFlags flags, uint32_t index, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdBeginQueryIndexedEXT, (VkCommandBuffer)(commandBuffer), (VkQueryPool)(queryPool), query, static_cast<VkQueryControlFlags>(flags), index); }
inline void cmdEndQueryIndexedEXT(CommandBuffer commandBuffer, QueryPool queryPool, uint32_t query, uint32_t index, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdEndQueryIndexedEXT, (VkCommandBuffer)(commandBuffer), (VkQueryPool)(queryPool), query, index); }
inline void cmdDrawIndirectByteCountEXT(CommandBuffer commandBuffer, uint32_t instanceCount, uint32_t firstInstance, Buffer counterBuffer, DeviceSize counterBufferOffset, uint32_t counterOffset, uint32_t vertexStride, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdDrawIndirectByteCountEXT, (VkCommandBuffer)(commandBuffer), instanceCount, firstInstance, (VkBuffer)(counterBuffer), counterBufferOffset, counterOffset, vertexStride); }

inline void cmdDrawIndirectCountKHR(CommandBuffer commandBuffer, Buffer buffer, DeviceSize offset, Buffer countBuffer, DeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdDrawIndirectCountKHR, (VkCommandBuffer)(commandBuffer), (VkBuffer)(buffer), offset, (VkBuffer)(countBuffer), countBufferOffset, maxDrawCount, stride); }
inline void cmdDrawIndirectCountAMD(CommandBuffer commandBuffer, Buffer buffer, DeviceSize offset, Buffer countBuffer, DeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdDrawIndirectCountKHR, (VkCommandBuffer)(commandBuffer), (VkBuffer)(buffer), offset, (VkBuffer)(countBuffer), countBufferOffset, maxDrawCount, stride); }
inline void cmdDrawIndexedIndirectCountKHR(CommandBuffer commandBuffer, Buffer buffer, DeviceSize offset, Buffer countBuffer, DeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdDrawIndexedIndirectCountKHR, (VkCommandBuffer)(commandBuffer), (VkBuffer)(buffer), offset, (VkBuffer)(countBuffer), countBufferOffset, maxDrawCount, stride); }
inline void cmdDrawIndexedIndirectCountAMD(CommandBuffer commandBuffer, Buffer buffer, DeviceSize offset, Buffer countBuffer, DeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdDrawIndexedIndirectCountKHR, (VkCommandBuffer)(commandBuffer), (VkBuffer)(buffer), offset, (VkBuffer)(countBuffer), countBufferOffset, maxDrawCount, stride); }

inline Result getShaderInfoAMD(Device device, Pipeline pipeline, ShaderStageBits shaderStage, ShaderInfoTypeAMD infoType, size_t& pInfoSize, void* pInfo = {}, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetShaderInfoAMD, (VkDevice)(device), (VkPipeline)(pipeline), static_cast<VkShaderStageFlagBits>(shaderStage), static_cast<VkShaderInfoTypeAMD>(infoType), (size_t*)(&pInfoSize), (void*)(pInfo)))); }
inline std::vector<uint8_t> getShaderInfoAMD(Device device, Pipeline pipeline, ShaderStageBits shaderStage, ShaderInfoTypeAMD infoType, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC_G(dispatcher, uint8_t, size_t, vkGetShaderInfoAMD, (VkDevice)(device), (VkPipeline)(pipeline), static_cast<VkShaderStageFlagBits>(shaderStage), static_cast<VkShaderInfoTypeAMD>(infoType), &count, (void*)(ret.data()));  }

#ifdef VK_USE_PLATFORM_GGP

inline SurfaceKHR createStreamDescriptorSurfaceGGP(Instance instance, const StreamDescriptorSurfaceCreateInfoGGP& pCreateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ SurfaceKHR ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkCreateStreamDescriptorSurfaceGGP, (VkInstance)(instance), (const VkStreamDescriptorSurfaceCreateInfoGGP*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkSurfaceKHR*)(&ret))); return ret; }

#endif //VK_USE_PLATFORM_GGP

inline ExternalImageFormatPropertiesNV getPhysicalDeviceExternalImageFormatPropertiesNV(PhysicalDevice physicalDevice, Format format, ImageType type, ImageTiling tiling, ImageUsageFlags usage, ImageCreateFlags flags = {}, ExternalMemoryHandleTypeFlagsNV externalHandleType = {}, DynamicDispatch* dispatcher = nullptr){ ExternalImageFormatPropertiesNV ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPhysicalDeviceExternalImageFormatPropertiesNV, (VkPhysicalDevice)(physicalDevice), static_cast<VkFormat>(format), static_cast<VkImageType>(type), static_cast<VkImageTiling>(tiling), static_cast<VkImageUsageFlags>(usage), static_cast<VkImageCreateFlags>(flags), static_cast<VkExternalMemoryHandleTypeFlagsNV>(externalHandleType), (VkExternalImageFormatPropertiesNV*)(&ret))); return ret; }

#ifdef VK_USE_PLATFORM_WIN32_KHR

inline HANDLE getMemoryWin32HandleNV(Device device, DeviceMemory memory, ExternalMemoryHandleTypeFlagsNV handleType, DynamicDispatch* dispatcher = nullptr){ HANDLE ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetMemoryWin32HandleNV, (VkDevice)(device), (VkDeviceMemory)(memory), static_cast<VkExternalMemoryHandleTypeFlagsNV>(handleType), (HANDLE*)(&ret))); return ret; }

#endif //VK_USE_PLATFORM_WIN32_KHR

inline DeviceGroupPresentModeFlagsKHR getDeviceGroupSurfacePresentModes2EXT(Device device, const PhysicalDeviceSurfaceInfo2KHR& pSurfaceInfo, DynamicDispatch* dispatcher = nullptr){ DeviceGroupPresentModeFlagsKHR ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetDeviceGroupSurfacePresentModes2EXT, (VkDevice)(device), (const VkPhysicalDeviceSurfaceInfo2KHR*)(&pSurfaceInfo), (VkDeviceGroupPresentModeFlagsKHR*)(&ret))); return ret; }

#ifdef VK_USE_PLATFORM_VI_NN

inline SurfaceKHR createViSurfaceNN(Instance instance, const ViSurfaceCreateInfoNN& pCreateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ SurfaceKHR ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkCreateViSurfaceNN, (VkInstance)(instance), (const VkViSurfaceCreateInfoNN*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkSurfaceKHR*)(&ret))); return ret; }

#endif //VK_USE_PLATFORM_VI_NN

#ifdef VK_USE_PLATFORM_WIN32_KHR

inline HANDLE getMemoryWin32HandleKHR(Device device, const MemoryGetWin32HandleInfoKHR& pGetWin32HandleInfo, DynamicDispatch* dispatcher = nullptr){ HANDLE ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetMemoryWin32HandleKHR, (VkDevice)(device), (const VkMemoryGetWin32HandleInfoKHR*)(&pGetWin32HandleInfo), (HANDLE*)(&ret))); return ret; }
inline MemoryWin32HandlePropertiesKHR getMemoryWin32HandlePropertiesKHR(Device device, ExternalMemoryHandleTypeBits handleType, HANDLE handle, DynamicDispatch* dispatcher = nullptr){ MemoryWin32HandlePropertiesKHR ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetMemoryWin32HandlePropertiesKHR, (VkDevice)(device), static_cast<VkExternalMemoryHandleTypeFlagBits>(handleType), handle, (VkMemoryWin32HandlePropertiesKHR*)(&ret))); return ret; }

#endif //VK_USE_PLATFORM_WIN32_KHR

inline int getMemoryFdKHR(Device device, const MemoryGetFdInfoKHR& pGetFdInfo, DynamicDispatch* dispatcher = nullptr){ int ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetMemoryFdKHR, (VkDevice)(device), (const VkMemoryGetFdInfoKHR*)(&pGetFdInfo), (int*)(&ret))); return ret; }
inline MemoryFdPropertiesKHR getMemoryFdPropertiesKHR(Device device, ExternalMemoryHandleTypeBits handleType, int fd, DynamicDispatch* dispatcher = nullptr){ MemoryFdPropertiesKHR ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetMemoryFdPropertiesKHR, (VkDevice)(device), static_cast<VkExternalMemoryHandleTypeFlagBits>(handleType), fd, (VkMemoryFdPropertiesKHR*)(&ret))); return ret; }

#ifdef VK_USE_PLATFORM_WIN32_KHR

inline Result importSemaphoreWin32HandleKHR(Device device, const ImportSemaphoreWin32HandleInfoKHR& pImportSemaphoreWin32HandleInfo, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkImportSemaphoreWin32HandleKHR, (VkDevice)(device), (const VkImportSemaphoreWin32HandleInfoKHR*)(&pImportSemaphoreWin32HandleInfo)))); }
inline HANDLE getSemaphoreWin32HandleKHR(Device device, const SemaphoreGetWin32HandleInfoKHR& pGetWin32HandleInfo, DynamicDispatch* dispatcher = nullptr){ HANDLE ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetSemaphoreWin32HandleKHR, (VkDevice)(device), (const VkSemaphoreGetWin32HandleInfoKHR*)(&pGetWin32HandleInfo), (HANDLE*)(&ret))); return ret; }

#endif //VK_USE_PLATFORM_WIN32_KHR

inline Result importSemaphoreFdKHR(Device device, const ImportSemaphoreFdInfoKHR& pImportSemaphoreFdInfo, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkImportSemaphoreFdKHR, (VkDevice)(device), (const VkImportSemaphoreFdInfoKHR*)(&pImportSemaphoreFdInfo)))); }
inline int getSemaphoreFdKHR(Device device, const SemaphoreGetFdInfoKHR& pGetFdInfo, DynamicDispatch* dispatcher = nullptr){ int ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetSemaphoreFdKHR, (VkDevice)(device), (const VkSemaphoreGetFdInfoKHR*)(&pGetFdInfo), (int*)(&ret))); return ret; }

inline void cmdPushDescriptorSetKHR(CommandBuffer commandBuffer, PipelineBindPoint pipelineBindPoint, PipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount, const WriteDescriptorSet& pDescriptorWrites, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdPushDescriptorSetKHR, (VkCommandBuffer)(commandBuffer), static_cast<VkPipelineBindPoint>(pipelineBindPoint), (VkPipelineLayout)(layout), set, descriptorWriteCount, (const VkWriteDescriptorSet*)(&pDescriptorWrites)); }
inline void cmdPushDescriptorSetKHR(CommandBuffer commandBuffer, PipelineBindPoint pipelineBindPoint, PipelineLayout layout, uint32_t set, Span<const WriteDescriptorSet> pDescriptorWrites, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdPushDescriptorSetKHR, (VkCommandBuffer)(commandBuffer), static_cast<VkPipelineBindPoint>(pipelineBindPoint), (VkPipelineLayout)(layout), set, pDescriptorWrites.size(), (const VkWriteDescriptorSet*)(pDescriptorWrites.data())); }
inline void cmdPushDescriptorSetWithTemplateKHR(CommandBuffer commandBuffer, DescriptorUpdateTemplate descriptorUpdateTemplate, PipelineLayout layout, uint32_t set, const void* pData, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdPushDescriptorSetWithTemplateKHR, (VkCommandBuffer)(commandBuffer), (VkDescriptorUpdateTemplate)(descriptorUpdateTemplate), (VkPipelineLayout)(layout), set, (const void*)(pData)); }

inline void cmdBeginConditionalRenderingEXT(CommandBuffer commandBuffer, const ConditionalRenderingBeginInfoEXT& pConditionalRenderingBegin, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdBeginConditionalRenderingEXT, (VkCommandBuffer)(commandBuffer), (const VkConditionalRenderingBeginInfoEXT*)(&pConditionalRenderingBegin)); }
inline void cmdEndConditionalRenderingEXT(CommandBuffer commandBuffer, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdEndConditionalRenderingEXT, (VkCommandBuffer)(commandBuffer)); }

inline void cmdSetViewportWScalingNV(CommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const ViewportWScalingNV& pViewportWScalings, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdSetViewportWScalingNV, (VkCommandBuffer)(commandBuffer), firstViewport, viewportCount, (const VkViewportWScalingNV*)(&pViewportWScalings)); }
inline void cmdSetViewportWScalingNV(CommandBuffer commandBuffer, uint32_t firstViewport, Span<const ViewportWScalingNV> pViewportWScalings, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdSetViewportWScalingNV, (VkCommandBuffer)(commandBuffer), firstViewport, pViewportWScalings.size(), (const VkViewportWScalingNV*)(pViewportWScalings.data())); }

inline Result releaseDisplayEXT(PhysicalDevice physicalDevice, DisplayKHR display, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkReleaseDisplayEXT, (VkPhysicalDevice)(physicalDevice), (VkDisplayKHR)(display)))); }

#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT

inline Display acquireXlibDisplayEXT(PhysicalDevice physicalDevice, DisplayKHR display, DynamicDispatch* dispatcher = nullptr){ Display ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkAcquireXlibDisplayEXT, (VkPhysicalDevice)(physicalDevice), (Display*)(&ret), (VkDisplayKHR)(display))); return ret; }
inline DisplayKHR getRandROutputDisplayEXT(PhysicalDevice physicalDevice, Display& dpy, RROutput rrOutput, DynamicDispatch* dispatcher = nullptr){ DisplayKHR ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetRandROutputDisplayEXT, (VkPhysicalDevice)(physicalDevice), (Display*)(&dpy), rrOutput, (VkDisplayKHR*)(&ret))); return ret; }

#endif //VK_USE_PLATFORM_XLIB_XRANDR_EXT

inline SurfaceCapabilities2EXT getPhysicalDeviceSurfaceCapabilities2EXT(PhysicalDevice physicalDevice, SurfaceKHR surface, DynamicDispatch* dispatcher = nullptr){ SurfaceCapabilities2EXT ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPhysicalDeviceSurfaceCapabilities2EXT, (VkPhysicalDevice)(physicalDevice), (VkSurfaceKHR)(surface), (VkSurfaceCapabilities2EXT*)(&ret))); return ret; }

inline Result displayPowerControlEXT(Device device, DisplayKHR display, const DisplayPowerInfoEXT& pDisplayPowerInfo, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkDisplayPowerControlEXT, (VkDevice)(device), (VkDisplayKHR)(display), (const VkDisplayPowerInfoEXT*)(&pDisplayPowerInfo)))); }
inline Fence registerDeviceEventEXT(Device device, const DeviceEventInfoEXT& pDeviceEventInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ Fence ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkRegisterDeviceEventEXT, (VkDevice)(device), (const VkDeviceEventInfoEXT*)(&pDeviceEventInfo), (const VkAllocationCallbacks*)(pAllocator), (VkFence*)(&ret))); return ret; }
inline Fence registerDisplayEventEXT(Device device, DisplayKHR display, const DisplayEventInfoEXT& pDisplayEventInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ Fence ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkRegisterDisplayEventEXT, (VkDevice)(device), (VkDisplayKHR)(display), (const VkDisplayEventInfoEXT*)(&pDisplayEventInfo), (const VkAllocationCallbacks*)(pAllocator), (VkFence*)(&ret))); return ret; }
inline uint64_t getSwapchainCounterEXT(Device device, SwapchainKHR swapchain, SurfaceCounterBitsEXT counter, DynamicDispatch* dispatcher = nullptr){ uint64_t ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetSwapchainCounterEXT, (VkDevice)(device), (VkSwapchainKHR)(swapchain), static_cast<VkSurfaceCounterFlagBitsEXT>(counter), (uint64_t*)(&ret))); return ret; }

inline RefreshCycleDurationGOOGLE getRefreshCycleDurationGOOGLE(Device device, SwapchainKHR swapchain, DynamicDispatch* dispatcher = nullptr){ RefreshCycleDurationGOOGLE ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetRefreshCycleDurationGOOGLE, (VkDevice)(device), (VkSwapchainKHR)(swapchain), (VkRefreshCycleDurationGOOGLE*)(&ret))); return ret; }
inline Result getPastPresentationTimingGOOGLE(Device device, SwapchainKHR swapchain, uint32_t& pPresentationTimingCount, PastPresentationTimingGOOGLE* pPresentationTimings = {}, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPastPresentationTimingGOOGLE, (VkDevice)(device), (VkSwapchainKHR)(swapchain), (uint32_t*)(&pPresentationTimingCount), (VkPastPresentationTimingGOOGLE*)(pPresentationTimings)))); }
inline std::vector<PastPresentationTimingGOOGLE> getPastPresentationTimingGOOGLE(Device device, SwapchainKHR swapchain, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC_G(dispatcher, PastPresentationTimingGOOGLE, uint32_t, vkGetPastPresentationTimingGOOGLE, (VkDevice)(device), (VkSwapchainKHR)(swapchain), &count, (VkPastPresentationTimingGOOGLE*)(ret.data()));  }

inline void cmdSetDiscardRectangleEXT(CommandBuffer commandBuffer, uint32_t firstDiscardRectangle, uint32_t discardRectangleCount, const Rect2D& pDiscardRectangles, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdSetDiscardRectangleEXT, (VkCommandBuffer)(commandBuffer), firstDiscardRectangle, discardRectangleCount, (const VkRect2D*)(&pDiscardRectangles)); }
inline void cmdSetDiscardRectangleEXT(CommandBuffer commandBuffer, uint32_t firstDiscardRectangle, Span<const Rect2D> pDiscardRectangles, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdSetDiscardRectangleEXT, (VkCommandBuffer)(commandBuffer), firstDiscardRectangle, pDiscardRectangles.size(), (const VkRect2D*)(pDiscardRectangles.data())); }

inline void setHdrMetadataEXT(Device device, uint32_t swapchainCount, const SwapchainKHR& pSwapchains, const HdrMetadataEXT& pMetadata, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkSetHdrMetadataEXT, (VkDevice)(device), swapchainCount, (const VkSwapchainKHR*)(&pSwapchains), (const VkHdrMetadataEXT*)(&pMetadata)); }
inline void setHdrMetadataEXT(Device device, Span<const SwapchainKHR> pSwapchains, Span<const HdrMetadataEXT> pMetadata, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkSetHdrMetadataEXT, (VkDevice)(device), pSwapchains.size(), (const VkSwapchainKHR*)(pSwapchains.data()), (const VkHdrMetadataEXT*)(pMetadata.data())); }

inline RenderPass createRenderPass2KHR(Device device, const RenderPassCreateInfo2KHR& pCreateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ RenderPass ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkCreateRenderPass2KHR, (VkDevice)(device), (const VkRenderPassCreateInfo2KHR*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkRenderPass*)(&ret))); return ret; }
inline void cmdBeginRenderPass2KHR(CommandBuffer commandBuffer, const RenderPassBeginInfo& pRenderPassBegin, const SubpassBeginInfoKHR& pSubpassBeginInfo, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdBeginRenderPass2KHR, (VkCommandBuffer)(commandBuffer), (const VkRenderPassBeginInfo*)(&pRenderPassBegin), (const VkSubpassBeginInfoKHR*)(&pSubpassBeginInfo)); }
inline void cmdNextSubpass2KHR(CommandBuffer commandBuffer, const SubpassBeginInfoKHR& pSubpassBeginInfo, const SubpassEndInfoKHR& pSubpassEndInfo, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdNextSubpass2KHR, (VkCommandBuffer)(commandBuffer), (const VkSubpassBeginInfoKHR*)(&pSubpassBeginInfo), (const VkSubpassEndInfoKHR*)(&pSubpassEndInfo)); }
inline void cmdEndRenderPass2KHR(CommandBuffer commandBuffer, const SubpassEndInfoKHR& pSubpassEndInfo, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdEndRenderPass2KHR, (VkCommandBuffer)(commandBuffer), (const VkSubpassEndInfoKHR*)(&pSubpassEndInfo)); }

inline Result getSwapchainStatusKHR(Device device, SwapchainKHR swapchain, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetSwapchainStatusKHR, (VkDevice)(device), (VkSwapchainKHR)(swapchain)))); }

#ifdef VK_USE_PLATFORM_WIN32_KHR

inline Result importFenceWin32HandleKHR(Device device, const ImportFenceWin32HandleInfoKHR& pImportFenceWin32HandleInfo, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkImportFenceWin32HandleKHR, (VkDevice)(device), (const VkImportFenceWin32HandleInfoKHR*)(&pImportFenceWin32HandleInfo)))); }
inline HANDLE getFenceWin32HandleKHR(Device device, const FenceGetWin32HandleInfoKHR& pGetWin32HandleInfo, DynamicDispatch* dispatcher = nullptr){ HANDLE ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetFenceWin32HandleKHR, (VkDevice)(device), (const VkFenceGetWin32HandleInfoKHR*)(&pGetWin32HandleInfo), (HANDLE*)(&ret))); return ret; }

#endif //VK_USE_PLATFORM_WIN32_KHR

inline Result importFenceFdKHR(Device device, const ImportFenceFdInfoKHR& pImportFenceFdInfo, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkImportFenceFdKHR, (VkDevice)(device), (const VkImportFenceFdInfoKHR*)(&pImportFenceFdInfo)))); }
inline int getFenceFdKHR(Device device, const FenceGetFdInfoKHR& pGetFdInfo, DynamicDispatch* dispatcher = nullptr){ int ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetFenceFdKHR, (VkDevice)(device), (const VkFenceGetFdInfoKHR*)(&pGetFdInfo), (int*)(&ret))); return ret; }

inline SurfaceCapabilities2KHR getPhysicalDeviceSurfaceCapabilities2KHR(PhysicalDevice physicalDevice, const PhysicalDeviceSurfaceInfo2KHR& pSurfaceInfo, DynamicDispatch* dispatcher = nullptr){ SurfaceCapabilities2KHR ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPhysicalDeviceSurfaceCapabilities2KHR, (VkPhysicalDevice)(physicalDevice), (const VkPhysicalDeviceSurfaceInfo2KHR*)(&pSurfaceInfo), (VkSurfaceCapabilities2KHR*)(&ret))); return ret; }
inline Result getPhysicalDeviceSurfaceFormats2KHR(PhysicalDevice physicalDevice, const PhysicalDeviceSurfaceInfo2KHR& pSurfaceInfo, uint32_t& pSurfaceFormatCount, SurfaceFormat2KHR* pSurfaceFormats = {}, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPhysicalDeviceSurfaceFormats2KHR, (VkPhysicalDevice)(physicalDevice), (const VkPhysicalDeviceSurfaceInfo2KHR*)(&pSurfaceInfo), (uint32_t*)(&pSurfaceFormatCount), (VkSurfaceFormat2KHR*)(pSurfaceFormats)))); }
inline std::vector<SurfaceFormat2KHR> getPhysicalDeviceSurfaceFormats2KHR(PhysicalDevice physicalDevice, const PhysicalDeviceSurfaceInfo2KHR& pSurfaceInfo, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC_G(dispatcher, SurfaceFormat2KHR, uint32_t, vkGetPhysicalDeviceSurfaceFormats2KHR, (VkPhysicalDevice)(physicalDevice), (const VkPhysicalDeviceSurfaceInfo2KHR*)(&pSurfaceInfo), &count, (VkSurfaceFormat2KHR*)(ret.data()));  }

inline Result getPhysicalDeviceDisplayProperties2KHR(PhysicalDevice physicalDevice, uint32_t& pPropertyCount, DisplayProperties2KHR* pProperties = {}, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPhysicalDeviceDisplayProperties2KHR, (VkPhysicalDevice)(physicalDevice), (uint32_t*)(&pPropertyCount), (VkDisplayProperties2KHR*)(pProperties)))); }
inline std::vector<DisplayProperties2KHR> getPhysicalDeviceDisplayProperties2KHR(PhysicalDevice physicalDevice, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC_G(dispatcher, DisplayProperties2KHR, uint32_t, vkGetPhysicalDeviceDisplayProperties2KHR, (VkPhysicalDevice)(physicalDevice), &count, (VkDisplayProperties2KHR*)(ret.data()));  }
inline Result getPhysicalDeviceDisplayPlaneProperties2KHR(PhysicalDevice physicalDevice, uint32_t& pPropertyCount, DisplayPlaneProperties2KHR* pProperties = {}, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPhysicalDeviceDisplayPlaneProperties2KHR, (VkPhysicalDevice)(physicalDevice), (uint32_t*)(&pPropertyCount), (VkDisplayPlaneProperties2KHR*)(pProperties)))); }
inline std::vector<DisplayPlaneProperties2KHR> getPhysicalDeviceDisplayPlaneProperties2KHR(PhysicalDevice physicalDevice, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC_G(dispatcher, DisplayPlaneProperties2KHR, uint32_t, vkGetPhysicalDeviceDisplayPlaneProperties2KHR, (VkPhysicalDevice)(physicalDevice), &count, (VkDisplayPlaneProperties2KHR*)(ret.data()));  }
inline Result getDisplayModeProperties2KHR(PhysicalDevice physicalDevice, DisplayKHR display, uint32_t& pPropertyCount, DisplayModeProperties2KHR* pProperties = {}, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetDisplayModeProperties2KHR, (VkPhysicalDevice)(physicalDevice), (VkDisplayKHR)(display), (uint32_t*)(&pPropertyCount), (VkDisplayModeProperties2KHR*)(pProperties)))); }
inline std::vector<DisplayModeProperties2KHR> getDisplayModeProperties2KHR(PhysicalDevice physicalDevice, DisplayKHR display, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC_G(dispatcher, DisplayModeProperties2KHR, uint32_t, vkGetDisplayModeProperties2KHR, (VkPhysicalDevice)(physicalDevice), (VkDisplayKHR)(display), &count, (VkDisplayModeProperties2KHR*)(ret.data()));  }
inline DisplayPlaneCapabilities2KHR getDisplayPlaneCapabilities2KHR(PhysicalDevice physicalDevice, const DisplayPlaneInfo2KHR& pDisplayPlaneInfo, DynamicDispatch* dispatcher = nullptr){ DisplayPlaneCapabilities2KHR ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetDisplayPlaneCapabilities2KHR, (VkPhysicalDevice)(physicalDevice), (const VkDisplayPlaneInfo2KHR*)(&pDisplayPlaneInfo), (VkDisplayPlaneCapabilities2KHR*)(&ret))); return ret; }

#ifdef VK_USE_PLATFORM_IOS_MVK

inline SurfaceKHR createIOSSurfaceMVK(Instance instance, const IOSSurfaceCreateInfoMVK& pCreateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ SurfaceKHR ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkCreateIOSSurfaceMVK, (VkInstance)(instance), (const VkIOSSurfaceCreateInfoMVK*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkSurfaceKHR*)(&ret))); return ret; }

#endif //VK_USE_PLATFORM_IOS_MVK

#ifdef VK_USE_PLATFORM_MACOS_MVK

inline SurfaceKHR createMacOSSurfaceMVK(Instance instance, const MacOSSurfaceCreateInfoMVK& pCreateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ SurfaceKHR ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkCreateMacOSSurfaceMVK, (VkInstance)(instance), (const VkMacOSSurfaceCreateInfoMVK*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkSurfaceKHR*)(&ret))); return ret; }

#endif //VK_USE_PLATFORM_MACOS_MVK

inline Result setDebugUtilsObjectNameEXT(Device device, const DebugUtilsObjectNameInfoEXT& pNameInfo, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkSetDebugUtilsObjectNameEXT, (VkDevice)(device), (const VkDebugUtilsObjectNameInfoEXT*)(&pNameInfo)))); }
inline Result setDebugUtilsObjectTagEXT(Device device, const DebugUtilsObjectTagInfoEXT& pTagInfo, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkSetDebugUtilsObjectTagEXT, (VkDevice)(device), (const VkDebugUtilsObjectTagInfoEXT*)(&pTagInfo)))); }
inline void queueBeginDebugUtilsLabelEXT(Queue queue, const DebugUtilsLabelEXT& pLabelInfo, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkQueueBeginDebugUtilsLabelEXT, (VkQueue)(queue), (const VkDebugUtilsLabelEXT*)(&pLabelInfo)); }
inline void queueEndDebugUtilsLabelEXT(Queue queue, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkQueueEndDebugUtilsLabelEXT, (VkQueue)(queue)); }
inline void queueInsertDebugUtilsLabelEXT(Queue queue, const DebugUtilsLabelEXT& pLabelInfo, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkQueueInsertDebugUtilsLabelEXT, (VkQueue)(queue), (const VkDebugUtilsLabelEXT*)(&pLabelInfo)); }
inline void cmdBeginDebugUtilsLabelEXT(CommandBuffer commandBuffer, const DebugUtilsLabelEXT& pLabelInfo, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdBeginDebugUtilsLabelEXT, (VkCommandBuffer)(commandBuffer), (const VkDebugUtilsLabelEXT*)(&pLabelInfo)); }
inline void cmdEndDebugUtilsLabelEXT(CommandBuffer commandBuffer, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdEndDebugUtilsLabelEXT, (VkCommandBuffer)(commandBuffer)); }
inline void cmdInsertDebugUtilsLabelEXT(CommandBuffer commandBuffer, const DebugUtilsLabelEXT& pLabelInfo, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdInsertDebugUtilsLabelEXT, (VkCommandBuffer)(commandBuffer), (const VkDebugUtilsLabelEXT*)(&pLabelInfo)); }
inline DebugUtilsMessengerEXT createDebugUtilsMessengerEXT(Instance instance, const DebugUtilsMessengerCreateInfoEXT& pCreateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ DebugUtilsMessengerEXT ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkCreateDebugUtilsMessengerEXT, (VkInstance)(instance), (const VkDebugUtilsMessengerCreateInfoEXT*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkDebugUtilsMessengerEXT*)(&ret))); return ret; }
inline void destroyDebugUtilsMessengerEXT(Instance instance, DebugUtilsMessengerEXT messenger, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkDestroyDebugUtilsMessengerEXT, (VkInstance)(instance), (VkDebugUtilsMessengerEXT)(messenger), (const VkAllocationCallbacks*)(pAllocator)); }
inline void submitDebugUtilsMessageEXT(Instance instance, DebugUtilsMessageSeverityBitsEXT messageSeverity, DebugUtilsMessageTypeFlagsEXT messageTypes, const DebugUtilsMessengerCallbackDataEXT& pCallbackData, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkSubmitDebugUtilsMessageEXT, (VkInstance)(instance), static_cast<VkDebugUtilsMessageSeverityFlagBitsEXT>(messageSeverity), static_cast<VkDebugUtilsMessageTypeFlagsEXT>(messageTypes), (const VkDebugUtilsMessengerCallbackDataEXT*)(&pCallbackData)); }

inline void cmdSetSampleLocationsEXT(CommandBuffer commandBuffer, const SampleLocationsInfoEXT& pSampleLocationsInfo, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdSetSampleLocationsEXT, (VkCommandBuffer)(commandBuffer), (const VkSampleLocationsInfoEXT*)(&pSampleLocationsInfo)); }
inline MultisamplePropertiesEXT getPhysicalDeviceMultisamplePropertiesEXT(PhysicalDevice physicalDevice, SampleCountBits samples, DynamicDispatch* dispatcher = nullptr){ MultisamplePropertiesEXT ret = {}; VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPhysicalDeviceMultisamplePropertiesEXT, (VkPhysicalDevice)(physicalDevice), static_cast<VkSampleCountFlagBits>(samples), (VkMultisamplePropertiesEXT*)(&ret)); return ret; }

inline ImageDrmFormatModifierPropertiesEXT getImageDrmFormatModifierPropertiesEXT(Device device, Image image, DynamicDispatch* dispatcher = nullptr){ ImageDrmFormatModifierPropertiesEXT ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetImageDrmFormatModifierPropertiesEXT, (VkDevice)(device), (VkImage)(image), (VkImageDrmFormatModifierPropertiesEXT*)(&ret))); return ret; }

inline ValidationCacheEXT createValidationCacheEXT(Device device, const ValidationCacheCreateInfoEXT& pCreateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ ValidationCacheEXT ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkCreateValidationCacheEXT, (VkDevice)(device), (const VkValidationCacheCreateInfoEXT*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkValidationCacheEXT*)(&ret))); return ret; }
inline void destroyValidationCacheEXT(Device device, ValidationCacheEXT validationCache = {}, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkDestroyValidationCacheEXT, (VkDevice)(device), (VkValidationCacheEXT)(validationCache), (const VkAllocationCallbacks*)(pAllocator)); }
inline Result mergeValidationCachesEXT(Device device, ValidationCacheEXT dstCache, uint32_t srcCacheCount, const ValidationCacheEXT& pSrcCaches, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkMergeValidationCachesEXT, (VkDevice)(device), (VkValidationCacheEXT)(dstCache), srcCacheCount, (const VkValidationCacheEXT*)(&pSrcCaches)))); }
inline Result mergeValidationCachesEXT(Device device, ValidationCacheEXT dstCache, Span<const ValidationCacheEXT> pSrcCaches, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkMergeValidationCachesEXT, (VkDevice)(device), (VkValidationCacheEXT)(dstCache), pSrcCaches.size(), (const VkValidationCacheEXT*)(pSrcCaches.data())))); }
inline Result getValidationCacheDataEXT(Device device, ValidationCacheEXT validationCache, size_t& pDataSize, void* pData = {}, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetValidationCacheDataEXT, (VkDevice)(device), (VkValidationCacheEXT)(validationCache), (size_t*)(&pDataSize), (void*)(pData)))); }
inline std::vector<uint8_t> getValidationCacheDataEXT(Device device, ValidationCacheEXT validationCache, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC_G(dispatcher, uint8_t, size_t, vkGetValidationCacheDataEXT, (VkDevice)(device), (VkValidationCacheEXT)(validationCache), &count, (void*)(ret.data()));  }

inline void cmdBindShadingRateImageNV(CommandBuffer commandBuffer, ImageView imageView, ImageLayout imageLayout, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdBindShadingRateImageNV, (VkCommandBuffer)(commandBuffer), (VkImageView)(imageView), static_cast<VkImageLayout>(imageLayout)); }
inline void cmdSetViewportShadingRatePaletteNV(CommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const ShadingRatePaletteNV& pShadingRatePalettes, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdSetViewportShadingRatePaletteNV, (VkCommandBuffer)(commandBuffer), firstViewport, viewportCount, (const VkShadingRatePaletteNV*)(&pShadingRatePalettes)); }
inline void cmdSetViewportShadingRatePaletteNV(CommandBuffer commandBuffer, uint32_t firstViewport, Span<const ShadingRatePaletteNV> pShadingRatePalettes, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdSetViewportShadingRatePaletteNV, (VkCommandBuffer)(commandBuffer), firstViewport, pShadingRatePalettes.size(), (const VkShadingRatePaletteNV*)(pShadingRatePalettes.data())); }
inline void cmdSetCoarseSampleOrderNV(CommandBuffer commandBuffer, CoarseSampleOrderTypeNV sampleOrderType, uint32_t customSampleOrderCount, const CoarseSampleOrderCustomNV& pCustomSampleOrders, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdSetCoarseSampleOrderNV, (VkCommandBuffer)(commandBuffer), static_cast<VkCoarseSampleOrderTypeNV>(sampleOrderType), customSampleOrderCount, (const VkCoarseSampleOrderCustomNV*)(&pCustomSampleOrders)); }
inline void cmdSetCoarseSampleOrderNV(CommandBuffer commandBuffer, CoarseSampleOrderTypeNV sampleOrderType, Span<const CoarseSampleOrderCustomNV> pCustomSampleOrders, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdSetCoarseSampleOrderNV, (VkCommandBuffer)(commandBuffer), static_cast<VkCoarseSampleOrderTypeNV>(sampleOrderType), pCustomSampleOrders.size(), (const VkCoarseSampleOrderCustomNV*)(pCustomSampleOrders.data())); }

inline AccelerationStructureNV createAccelerationStructureNV(Device device, const AccelerationStructureCreateInfoNV& pCreateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ AccelerationStructureNV ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkCreateAccelerationStructureNV, (VkDevice)(device), (const VkAccelerationStructureCreateInfoNV*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkAccelerationStructureNV*)(&ret))); return ret; }
inline void destroyAccelerationStructureNV(Device device, AccelerationStructureNV accelerationStructure, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkDestroyAccelerationStructureNV, (VkDevice)(device), (VkAccelerationStructureNV)(accelerationStructure), (const VkAllocationCallbacks*)(pAllocator)); }
inline MemoryRequirements2KHR getAccelerationStructureMemoryRequirementsNV(Device device, const AccelerationStructureMemoryRequirementsInfoNV& pInfo, DynamicDispatch* dispatcher = nullptr){ MemoryRequirements2KHR ret = {}; VKPP_DISPATCH_GLOBAL(dispatcher, vkGetAccelerationStructureMemoryRequirementsNV, (VkDevice)(device), (const VkAccelerationStructureMemoryRequirementsInfoNV*)(&pInfo), (VkMemoryRequirements2KHR*)(&ret)); return ret; }
inline Result bindAccelerationStructureMemoryNV(Device device, uint32_t bindInfoCount, const BindAccelerationStructureMemoryInfoNV& pBindInfos, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkBindAccelerationStructureMemoryNV, (VkDevice)(device), bindInfoCount, (const VkBindAccelerationStructureMemoryInfoNV*)(&pBindInfos)))); }
inline Result bindAccelerationStructureMemoryNV(Device device, Span<const BindAccelerationStructureMemoryInfoNV> pBindInfos, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkBindAccelerationStructureMemoryNV, (VkDevice)(device), pBindInfos.size(), (const VkBindAccelerationStructureMemoryInfoNV*)(pBindInfos.data())))); }
inline void cmdBuildAccelerationStructureNV(CommandBuffer commandBuffer, const AccelerationStructureInfoNV& pInfo, Buffer instanceData, DeviceSize instanceOffset, Bool32 update, AccelerationStructureNV dst, AccelerationStructureNV src, Buffer scratch, DeviceSize scratchOffset, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdBuildAccelerationStructureNV, (VkCommandBuffer)(commandBuffer), (const VkAccelerationStructureInfoNV*)(&pInfo), (VkBuffer)(instanceData), instanceOffset, update, (VkAccelerationStructureNV)(dst), (VkAccelerationStructureNV)(src), (VkBuffer)(scratch), scratchOffset); }
inline void cmdCopyAccelerationStructureNV(CommandBuffer commandBuffer, AccelerationStructureNV dst, AccelerationStructureNV src, CopyAccelerationStructureModeNV mode, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdCopyAccelerationStructureNV, (VkCommandBuffer)(commandBuffer), (VkAccelerationStructureNV)(dst), (VkAccelerationStructureNV)(src), static_cast<VkCopyAccelerationStructureModeNV>(mode)); }
inline void cmdTraceRaysNV(CommandBuffer commandBuffer, Buffer raygenShaderBindingTableBuffer, DeviceSize raygenShaderBindingOffset, Buffer missShaderBindingTableBuffer, DeviceSize missShaderBindingOffset, DeviceSize missShaderBindingStride, Buffer hitShaderBindingTableBuffer, DeviceSize hitShaderBindingOffset, DeviceSize hitShaderBindingStride, Buffer callableShaderBindingTableBuffer, DeviceSize callableShaderBindingOffset, DeviceSize callableShaderBindingStride, uint32_t width, uint32_t height, uint32_t depth, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdTraceRaysNV, (VkCommandBuffer)(commandBuffer), (VkBuffer)(raygenShaderBindingTableBuffer), raygenShaderBindingOffset, (VkBuffer)(missShaderBindingTableBuffer), missShaderBindingOffset, missShaderBindingStride, (VkBuffer)(hitShaderBindingTableBuffer), hitShaderBindingOffset, hitShaderBindingStride, (VkBuffer)(callableShaderBindingTableBuffer), callableShaderBindingOffset, callableShaderBindingStride, width, height, depth); }
inline Result createRayTracingPipelinesNV(Device device, PipelineCache pipelineCache, uint32_t createInfoCount, const RayTracingPipelineCreateInfoNV& pCreateInfos, const AllocationCallbacks* pAllocator, Pipeline& pPipelines, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkCreateRayTracingPipelinesNV, (VkDevice)(device), (VkPipelineCache)(pipelineCache), createInfoCount, (const VkRayTracingPipelineCreateInfoNV*)(&pCreateInfos), (const VkAllocationCallbacks*)(pAllocator), (VkPipeline*)(&pPipelines)))); }
inline std::vector<Pipeline> createRayTracingPipelinesNV(Device device, PipelineCache pipelineCache, Span<const RayTracingPipelineCreateInfoNV> pCreateInfos, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC_RET_G(dispatcher, Pipeline, pCreateInfos.size(), vkCreateRayTracingPipelinesNV, (VkDevice)(device), (VkPipelineCache)(pipelineCache), pCreateInfos.size(), (const VkRayTracingPipelineCreateInfoNV*)(pCreateInfos.data()), (const VkAllocationCallbacks*)(pAllocator), (VkPipeline*)(ret.data()));  }
inline Result getRayTracingShaderGroupHandlesNV(Device device, Pipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void* pData, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetRayTracingShaderGroupHandlesNV, (VkDevice)(device), (VkPipeline)(pipeline), firstGroup, groupCount, dataSize, (void*)(pData)))); }
inline std::vector<uint8_t> getRayTracingShaderGroupHandlesNV(Device device, Pipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC_RET_G(dispatcher, uint8_t, dataSize, vkGetRayTracingShaderGroupHandlesNV, (VkDevice)(device), (VkPipeline)(pipeline), firstGroup, groupCount, dataSize, (void*)(ret.data()));  }
inline Result getAccelerationStructureHandleNV(Device device, AccelerationStructureNV accelerationStructure, size_t dataSize, void* pData, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetAccelerationStructureHandleNV, (VkDevice)(device), (VkAccelerationStructureNV)(accelerationStructure), dataSize, (void*)(pData)))); }
inline std::vector<uint8_t> getAccelerationStructureHandleNV(Device device, AccelerationStructureNV accelerationStructure, size_t dataSize, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC_RET_G(dispatcher, uint8_t, dataSize, vkGetAccelerationStructureHandleNV, (VkDevice)(device), (VkAccelerationStructureNV)(accelerationStructure), dataSize, (void*)(ret.data()));  }
inline void cmdWriteAccelerationStructuresPropertiesNV(CommandBuffer commandBuffer, uint32_t accelerationStructureCount, const AccelerationStructureNV& pAccelerationStructures, QueryType queryType, QueryPool queryPool, uint32_t firstQuery, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdWriteAccelerationStructuresPropertiesNV, (VkCommandBuffer)(commandBuffer), accelerationStructureCount, (const VkAccelerationStructureNV*)(&pAccelerationStructures), static_cast<VkQueryType>(queryType), (VkQueryPool)(queryPool), firstQuery); }
inline void cmdWriteAccelerationStructuresPropertiesNV(CommandBuffer commandBuffer, Span<const AccelerationStructureNV> pAccelerationStructures, QueryType queryType, QueryPool queryPool, uint32_t firstQuery, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdWriteAccelerationStructuresPropertiesNV, (VkCommandBuffer)(commandBuffer), pAccelerationStructures.size(), (const VkAccelerationStructureNV*)(pAccelerationStructures.data()), static_cast<VkQueryType>(queryType), (VkQueryPool)(queryPool), firstQuery); }
inline Result compileDeferredNV(Device device, Pipeline pipeline, uint32_t shader, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkCompileDeferredNV, (VkDevice)(device), (VkPipeline)(pipeline), shader))); }

inline MemoryHostPointerPropertiesEXT getMemoryHostPointerPropertiesEXT(Device device, ExternalMemoryHandleTypeBits handleType, const void* pHostPointer, DynamicDispatch* dispatcher = nullptr){ MemoryHostPointerPropertiesEXT ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetMemoryHostPointerPropertiesEXT, (VkDevice)(device), static_cast<VkExternalMemoryHandleTypeFlagBits>(handleType), (const void*)(pHostPointer), (VkMemoryHostPointerPropertiesEXT*)(&ret))); return ret; }

inline void cmdWriteBufferMarkerAMD(CommandBuffer commandBuffer, PipelineStageBits pipelineStage, Buffer dstBuffer, DeviceSize dstOffset, uint32_t marker, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdWriteBufferMarkerAMD, (VkCommandBuffer)(commandBuffer), static_cast<VkPipelineStageFlagBits>(pipelineStage), (VkBuffer)(dstBuffer), dstOffset, marker); }

inline Result getPhysicalDeviceCalibrateableTimeDomainsEXT(PhysicalDevice physicalDevice, uint32_t& pTimeDomainCount, TimeDomainEXT* pTimeDomains = {}, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPhysicalDeviceCalibrateableTimeDomainsEXT, (VkPhysicalDevice)(physicalDevice), (uint32_t*)(&pTimeDomainCount), (VkTimeDomainEXT*)(pTimeDomains)))); }
inline std::vector<TimeDomainEXT> getPhysicalDeviceCalibrateableTimeDomainsEXT(PhysicalDevice physicalDevice, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC_G(dispatcher, TimeDomainEXT, uint32_t, vkGetPhysicalDeviceCalibrateableTimeDomainsEXT, (VkPhysicalDevice)(physicalDevice), &count, (VkTimeDomainEXT*)(ret.data()));  }
inline uint64_t getCalibratedTimestampsEXT(Device device, uint32_t timestampCount, const CalibratedTimestampInfoEXT& pTimestampInfos, uint64_t& pTimestamps, DynamicDispatch* dispatcher = nullptr){ uint64_t ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetCalibratedTimestampsEXT, (VkDevice)(device), timestampCount, (const VkCalibratedTimestampInfoEXT*)(&pTimestampInfos), (uint64_t*)(&pTimestamps), (uint64_t*)(&ret))); return ret; }
inline uint64_t getCalibratedTimestampsEXT(Device device, Span<const CalibratedTimestampInfoEXT> pTimestampInfos, Span<uint64_t> pTimestamps, DynamicDispatch* dispatcher = nullptr){ uint64_t ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetCalibratedTimestampsEXT, (VkDevice)(device), pTimestampInfos.size(), (const VkCalibratedTimestampInfoEXT*)(pTimestampInfos.data()), (uint64_t*)(pTimestamps.data()), (uint64_t*)(&ret))); return ret; }

inline void cmdDrawMeshTasksNV(CommandBuffer commandBuffer, uint32_t taskCount, uint32_t firstTask, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdDrawMeshTasksNV, (VkCommandBuffer)(commandBuffer), taskCount, firstTask); }
inline void cmdDrawMeshTasksIndirectNV(CommandBuffer commandBuffer, Buffer buffer, DeviceSize offset, uint32_t drawCount, uint32_t stride, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdDrawMeshTasksIndirectNV, (VkCommandBuffer)(commandBuffer), (VkBuffer)(buffer), offset, drawCount, stride); }
inline void cmdDrawMeshTasksIndirectCountNV(CommandBuffer commandBuffer, Buffer buffer, DeviceSize offset, Buffer countBuffer, DeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdDrawMeshTasksIndirectCountNV, (VkCommandBuffer)(commandBuffer), (VkBuffer)(buffer), offset, (VkBuffer)(countBuffer), countBufferOffset, maxDrawCount, stride); }

inline void cmdSetExclusiveScissorNV(CommandBuffer commandBuffer, uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount, const Rect2D& pExclusiveScissors, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdSetExclusiveScissorNV, (VkCommandBuffer)(commandBuffer), firstExclusiveScissor, exclusiveScissorCount, (const VkRect2D*)(&pExclusiveScissors)); }
inline void cmdSetExclusiveScissorNV(CommandBuffer commandBuffer, uint32_t firstExclusiveScissor, Span<const Rect2D> pExclusiveScissors, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdSetExclusiveScissorNV, (VkCommandBuffer)(commandBuffer), firstExclusiveScissor, pExclusiveScissors.size(), (const VkRect2D*)(pExclusiveScissors.data())); }

inline void cmdSetCheckpointNV(CommandBuffer commandBuffer, const void* pCheckpointMarker, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkCmdSetCheckpointNV, (VkCommandBuffer)(commandBuffer), (const void*)(pCheckpointMarker)); }
inline void getQueueCheckpointDataNV(Queue queue, uint32_t& pCheckpointDataCount, CheckpointDataNV* pCheckpointData = {}, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkGetQueueCheckpointDataNV, (VkQueue)(queue), (uint32_t*)(&pCheckpointDataCount), (VkCheckpointDataNV*)(pCheckpointData)); }
inline std::vector<CheckpointDataNV> getQueueCheckpointDataNV(Queue queue, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC_VOID_G(dispatcher, CheckpointDataNV, uint32_t, vkGetQueueCheckpointDataNV, (VkQueue)(queue), &count, (VkCheckpointDataNV*)(ret.data()));  }

inline void setLocalDimmingAMD(Device device, SwapchainKHR swapChain, Bool32 localDimmingEnable, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkSetLocalDimmingAMD, (VkDevice)(device), (VkSwapchainKHR)(swapChain), localDimmingEnable); }

#ifdef VK_USE_PLATFORM_FUCHSIA

inline SurfaceKHR createImagePipeSurfaceFUCHSIA(Instance instance, const ImagePipeSurfaceCreateInfoFUCHSIA& pCreateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ SurfaceKHR ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkCreateImagePipeSurfaceFUCHSIA, (VkInstance)(instance), (const VkImagePipeSurfaceCreateInfoFUCHSIA*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkSurfaceKHR*)(&ret))); return ret; }

#endif //VK_USE_PLATFORM_FUCHSIA

inline DeviceAddress getBufferDeviceAddressEXT(Device device, const BufferDeviceAddressInfoEXT& pInfo, DynamicDispatch* dispatcher = nullptr){ return static_cast<DeviceAddress>(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetBufferDeviceAddressEXT, (VkDevice)(device), (const VkBufferDeviceAddressInfoEXT*)(&pInfo))); }

inline Result getPhysicalDeviceCooperativeMatrixPropertiesNV(PhysicalDevice physicalDevice, uint32_t& pPropertyCount, CooperativeMatrixPropertiesNV* pProperties = {}, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPhysicalDeviceCooperativeMatrixPropertiesNV, (VkPhysicalDevice)(physicalDevice), (uint32_t*)(&pPropertyCount), (VkCooperativeMatrixPropertiesNV*)(pProperties)))); }
inline std::vector<CooperativeMatrixPropertiesNV> getPhysicalDeviceCooperativeMatrixPropertiesNV(PhysicalDevice physicalDevice, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC_G(dispatcher, CooperativeMatrixPropertiesNV, uint32_t, vkGetPhysicalDeviceCooperativeMatrixPropertiesNV, (VkPhysicalDevice)(physicalDevice), &count, (VkCooperativeMatrixPropertiesNV*)(ret.data()));  }

#ifdef VK_USE_PLATFORM_WIN32_KHR

inline Result getPhysicalDeviceSurfacePresentModes2EXT(PhysicalDevice physicalDevice, const PhysicalDeviceSurfaceInfo2KHR& pSurfaceInfo, uint32_t& pPresentModeCount, PresentModeKHR* pPresentModes = {}, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkGetPhysicalDeviceSurfacePresentModes2EXT, (VkPhysicalDevice)(physicalDevice), (const VkPhysicalDeviceSurfaceInfo2KHR*)(&pSurfaceInfo), (uint32_t*)(&pPresentModeCount), (VkPresentModeKHR*)(pPresentModes)))); }
inline std::vector<PresentModeKHR> getPhysicalDeviceSurfacePresentModes2EXT(PhysicalDevice physicalDevice, const PhysicalDeviceSurfaceInfo2KHR& pSurfaceInfo, DynamicDispatch* dispatcher = nullptr){ VEC_FUNC_G(dispatcher, PresentModeKHR, uint32_t, vkGetPhysicalDeviceSurfacePresentModes2EXT, (VkPhysicalDevice)(physicalDevice), (const VkPhysicalDeviceSurfaceInfo2KHR*)(&pSurfaceInfo), &count, (VkPresentModeKHR*)(ret.data()));  }
inline Result acquireFullScreenExclusiveModeEXT(Device device, SwapchainKHR swapchain, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkAcquireFullScreenExclusiveModeEXT, (VkDevice)(device), (VkSwapchainKHR)(swapchain)))); }
inline Result releaseFullScreenExclusiveModeEXT(Device device, SwapchainKHR swapchain, DynamicDispatch* dispatcher = nullptr){ return static_cast<Result>(VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkReleaseFullScreenExclusiveModeEXT, (VkDevice)(device), (VkSwapchainKHR)(swapchain)))); }

#endif //VK_USE_PLATFORM_WIN32_KHR

inline SurfaceKHR createHeadlessSurfaceEXT(Instance instance, const HeadlessSurfaceCreateInfoEXT& pCreateInfo, const AllocationCallbacks* pAllocator = {}, DynamicDispatch* dispatcher = nullptr){ SurfaceKHR ret = {}; VKPP_CHECK(VKPP_DISPATCH_GLOBAL(dispatcher, vkCreateHeadlessSurfaceEXT, (VkInstance)(instance), (const VkHeadlessSurfaceCreateInfoEXT*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkSurfaceKHR*)(&ret))); return ret; }

inline void resetQueryPoolEXT(Device device, QueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, DynamicDispatch* dispatcher = nullptr){ return VKPP_DISPATCH_GLOBAL(dispatcher, vkResetQueryPoolEXT, (VkDevice)(device), (VkQueryPool)(queryPool), firstQuery, queryCount); }

#undef VEC_FUNC
#undef VEC_FUNC_VOID
#undef VEC_FUNC_RET
#undef VEC_FUNC_RET_VOID

} // namespace vk

// The specification (vk.xml) itself is published under the following license:

// Copyright (c) 2015-2019 The Khronos Group Inc.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// 
// ---- Exceptions to the Apache 2.0 License: ----
// 
// As an exception, if you use this Software to generate code and portions of
// this Software are embedded into the generated code as a result, you may
// redistribute such product without providing attribution as would otherwise
// be required by Sections 4(a), 4(b) and 4(d) of the License.
// 
// In addition, if you combine or link code generated by this Software with
// software that is licensed under the GPLv2 or the LGPL v2.0 or 2.1
// ("`Combined Software`") and if a court of competent jurisdiction determines
// that the patent provision (Section 3), the indemnity provision (Section 9)
// or other Section of the License conflicts with the conditions of the
// applicable GPL or LGPL license, you may retroactively and prospectively
// choose to deem waived or otherwise exclude such Section(s) of the License,
// but only in their entirety and only with respect to the Combined Software.
    